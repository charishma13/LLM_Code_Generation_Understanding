Run_ID,Iteration,Timestamp,model_name,reasoning_factor,context_type,Feedback,Human_Message,AI_Message,Updated_Coulomb_input
1,1,2025-04-03_11:28:07,o1,medium,short,"Result from the code generated:

            Your code resulted in the following error from 0 iterations. The threshold is 3. Resolve the error before the 3rd attempt:
            Error
            Traceback (most recent call last):
  File ""<string>"", line 567, in <module>
  File ""<string>"", line 114, in creating_dataframes
KeyError: 'a' 
            Review the specific part or function causing the error in the next iteration and correct it.
            ","Please review the raw code, which currently works perfectly for cubic box configurations, and modify the functions to adjust the method so that it accommodates triclinic box configurations instead.


import numpy as np
import pandas as pd
from scipy.special import erfc,erf
import math 

# defining all variables
atom_properties = {
    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},
    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},
}

# Trying for small configurations first
file_paths = [
    #    '../data/spce_sample_config_periodic4.txt',
    #    '../data/spce_sample_config_periodic2.txt',
    #    '../data/spce_sample_config_periodic3.txt',
        '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'
    ]

NIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],
 'M (number of SPC/E molecules)': [400, 300, 200, 100],
 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],
 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',
  '[27 Å, 30 Å, 36 Å]',
  '[30 Å, 30 Å, 30 Å]',
  '[36 Å, 36 Å, 36 Å]'],
 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',
  '[90°, 75°, 90°]',
  '[85°, 75°, 80°]',
  '[90°, 60°, 90°]'],
 'Number of Wave Vectors': [831, 1068, 838, 1028],
 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],
 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],
 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],
 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],
 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],
 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],
 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}

# Data processing




def extracting_positions(input_file):
        # Extract the positions from the .xyz file
    with open(input_file, ""r"") as file:
        lines = file.readlines()

    data_lines = lines[2:]

    data_list = []
    for line in data_lines:
        stripped_line = line.strip()
        parts = stripped_line.split()
        if len(parts) >= 5:  
            try:
                x, y, z = map(float, parts[1:4])
                atom_type = parts[4]
                data_list.append([x, y, z, atom_type])
            except ValueError:
                continue  

    # Create a DataFrame with all configurations
    columns = [""X"", ""Y"", ""Z"", ""Atom Type""]
    configuration = pd.DataFrame(data_list, columns=columns)

    configuration.index = range(1, len(configuration) + 1)

    configuration[""Molecule""] = ((configuration.index - 1) // 3) + 1
    
    return configuration

# create the target dataframes
def parse_cell_sides(sides_str):
    sides_str = sides_str.strip().strip('[]')
    parts = sides_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('Å', '')
        values.append(float(p))
    return values

def parse_cell_angles(angles_str):
    angles_str = angles_str.strip().strip('[]')
    parts = angles_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('°', '')
        values.append(float(p))
    return values

def creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):
    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)
    NIST_SPC_E_Water['Sum of energies'] = (
        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +
        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +
        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']
    )

    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')
    system = pd.DataFrame(file_paths, columns=[""file_paths""])
    system['configuration #'] = (
        system['file_paths']
        .str.extract(r'(\d+)', expand=False)
        .fillna('0')
        .astype(int)
    )

    def get_abcs_and_angles(conf_num):
        if conf_num in NIST_SPC_E_Water[""Configuration""].values:
            row = NIST_SPC_E_Water.loc[NIST_SPC_E_Water[""Configuration""] == conf_num]
            sides_str = row['Cell Side Lengths [a, b, c] (Å)'].values[0]
            angles_str = row['Cell Angles [α, β, γ] (degrees)'].values[0]
            sides = parse_cell_sides(sides_str)
            angles = parse_cell_angles(angles_str)
            return pd.Series({
                ""number of particles"": float(row[""M (number of SPC/E molecules)""].values[0]),
                ""a"": sides[0],
                ""b"": sides[1],
                ""c"": sides[2],
                ""alpha_deg"": angles[0],
                ""beta_deg"": angles[1],
                ""gamma_deg"": angles[2]
            })
        else:
            return pd.Series({
                ""number of particles"": 0.0,
                ""a"": 20.0,
                ""b"": 20.0,
                ""c"": 20.0,
                ""alpha_deg"": 90.0,
                ""beta_deg"": 90.0,
                ""gamma_deg"": 90.0
            })

    system = pd.concat([
        system,
        system[""configuration #""].apply(get_abcs_and_angles)
    ], axis=1)

    system['cutoff'] = 10.0
    system['alpha'] = system.apply(
        lambda row: 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] * row['b'] * row['c']) != 0 else 0.28,
        axis=1
    )

    system['kmax'] = 5
    system['ε0'] = float(8.854187817E-12)
    system['kB'] = float(1.3806488E-23)

    return system, force_field, NIST_SPC_E_Water

# pairwise dispersion energy functions

# Minimum Image Distance function and Pair Dispersion Energy calculation (Code 3)
def minimum_image_distance(r_ij, cell_length):
    # Apply the minimum image convention to distances.
    return r_ij - cell_length * np.round(r_ij / cell_length)

# pairwise dispersion energy operation
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    cx = c * math.cos(beta)
    sin_gamma = math.sin(gamma) if abs(math.sin(gamma)) > 1e-14 else 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def pair_dispersion_energy(system_data, configuration, force_field):
    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    total_dispersion_energy = 0.0
    num_atoms = len(positions)

    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            r_ij = positions[i] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)

            if 0 < distance < cutoff:
                type_i = atom_types[i]
                type_j = atom_types[j]
                if type_i not in force_field.index or type_j not in force_field.index:
                    continue

                epsilon_i = force_field.loc[type_i, 'epsilon']
                epsilon_j = force_field.loc[type_j, 'epsilon']
                sigma_i = force_field.loc[type_i, 'sigma']
                sigma_j = force_field.loc[type_j, 'sigma']

                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)
                sigma_ij = 0.5 * (sigma_i + sigma_j)
                s_over_r = sigma_ij / distance
                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)
                total_dispersion_energy += lj_pot

    return total_dispersion_energy

# Compute LRC energy
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    cx = c * math.cos(beta)
    sin_gamma = math.sin(gamma) if abs(math.sin(gamma)) > 1e-14 else 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_lrc_energy(system_row, force_field):
    U_lrc_total = 0.0
    cutoff = system_row['cutoff']

    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],
                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])
    volume = abs(np.linalg.det(h))

    for atom_type, atom_data in force_field.iterrows():
        num_particles = system_row['number of particles'] * atom_data['num_particles']
        rho = num_particles / volume
        sigma = atom_data['sigma']
        epsilon = atom_data['epsilon']

        if cutoff > 0:
            sc3 = (sigma / cutoff)**3
            sc9 = sc3**3
        else:
            sc3, sc9 = 0.0, 0.0

        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)
        U_lrc *= num_particles
        U_lrc_total += U_lrc

    return U_lrc_total

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    cx = c * math.cos(beta)
    sin_gamma = math.sin(gamma) if abs(math.sin(gamma)) > 1e-14 else 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def compute_real_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    cutoff = system_data[""cutoff""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    mol_ids = configuration[""Molecule""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])

    real_energy = 0.0
    n_atoms = len(positions)

    for j in range(n_atoms - 1):
        for l in range(j + 1, n_atoms):
            if mol_ids[j] == mol_ids[l]:
                continue
            r_ij = positions[l] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)
            if 1e-14 < distance < cutoff:
                q_j = charges[j]*e_charge
                q_l = charges[l]*e_charge
                r_m = distance*1e-10
                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)

    return real_energy

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    cx = c * math.cos(beta)
    sin_gamma = math.sin(gamma) if abs(math.sin(gamma)) > 1e-14 else 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_fourier_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    kmax = system_data[""kmax""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)
    V_m = abs(np.linalg.det(h))*(1e-10**3)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])
    charges_c = charges*e_charge

    positions_m = positions*1e-10
    prefactor = coulomb_factor/(2.0*V_m)

    alpha_m = alpha*1e10
    fourier_energy = 0.0

    max_sq = kmax*kmax + 2

    L_avg = (a + b + c)/3.0
    kfactor = 2.0*math.pi/(L_avg*1e-10)

    for kx in range(-kmax, kmax+1):
        for ky in range(-kmax, kmax+1):
            for kz in range(-kmax, kmax+1):
                if (kx == 0 and ky == 0 and kz == 0):
                    continue
                if (kx*kx + ky*ky + kz*kz) >= max_sq:
                    continue

                kx_m = kfactor*kx
                ky_m = kfactor*ky
                kz_m = kfactor*kz
                k_sq = kx_m**2 + ky_m**2 + kz_m**2
                if k_sq < 1e-14:
                    continue

                real_part = 0.0
                imag_part = 0.0
                for j, (xj, yj, zj) in enumerate(positions_m):
                    kr = kx_m*xj + ky_m*yj + kz_m*zj
                    real_part += charges_c[j]*math.cos(kr)
                    imag_part += charges_c[j]*math.sin(kr)

                sk_sq = real_part**2 + imag_part**2
                exp_factor = math.exp(-k_sq/(4.0*(alpha_m**2)))

                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq
                fourier_energy += term

    return fourier_energy


def compute_self_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    alpha_m = alpha*1e10
    sum_q2 = np.sum(charges_c**2)

    # standard Ewald self correction
    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2

    return self_energy


def compute_intra_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    unique_mols = np.unique(mol_ids)
    intra_energy = 0.0

    for m_id in unique_mols:
        idxs = np.where(mol_ids == m_id)[0]
        for i in range(len(idxs) - 1):
            for j in range(i + 1, len(idxs)):
                idx_i = idxs[i]
                idx_j = idxs[j]
                dx = positions[idx_j, 0] - positions[idx_i, 0]
                dy = positions[idx_j, 1] - positions[idx_i, 1]
                dz = positions[idx_j, 2] - positions[idx_i, 2]
                r = math.sqrt(dx**2 + dy**2 + dz**2)
                if r > 1e-14:
                    q_i = charges[idx_i]*e_charge
                    q_j = charges[idx_j]*e_charge
                    r_m = r*1e-10
                    erf_val = erf(alpha*r)
                    # negative sign for intramolecular.
                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val
                    intra_energy -= val

    return intra_energy


# DataFrame Descriptions:

# 1. NIST_TRICLINIC_SPC_E_Water DataFrame:
#    - Contains thermodynamic properties of SPC/E water configurations in both triclinic and monoclinic cells.
#    - Columns:
#        - 'Configuration' (int): Configuration ID (1-4).
#        - 'M (number of SPC/E molecules)' (int): Number of SPC/E molecules in the system.
#        - 'Cell Type' (str): Type of the cell (e.g., Triclinic, Monoclinic).
#        - 'Cell Side Lengths [a, b, c] (Å)' (list of strings): Cell side lengths in Ångströms.
#        - 'Cell Angles [α, β, γ] (degrees)' (list of strings): Cell angles in degrees.
#        - 'Number of Wave Vectors' (int): The number of wave vectors for each configuration.
#        - 'Edisp/kB (K)' (float): Dispersion energy in Kelvin.
#        - 'ELRC/kB (K)' (float): Long-range correction energy in Kelvin.
#        - 'Ereal/kB (K)' (float): Real energy in Kelvin.
#        - 'Efourier/kB (K)' (float): Fourier transform energy in Kelvin.
#        - 'Eself/kB (K)' (float): Self-interaction energy in Kelvin.
#        - 'Eintra/kB (K)' (float): Intra-molecular energy in Kelvin.
#        - 'Etotal/kB (K)' (float): Total energy in Kelvin.

# 2. force_field DataFrame:
#    - Contains force field parameters for SPC/E water, specifically for oxygen ('O') and hydrogen ('H').
#    - Columns:
#        - 'type' (str): Atom type ('O' or 'H').
#        - 'sigma' (float): Lennard-Jones parameter (Å).
#        - 'epsilon' (float): Lennard-Jones well depth (K).
#        - 'charge' (float): Partial charge (e).
#        - 'num_particles' (int): Number of particles per molecule.

# 3. system DataFrame:
#    - Contains metadata about each system configuration.
#    - Columns:
#        - 'file_paths' (str): File names containing atomic configurations.
#        - 'configuration #' (int): Extracted configuration number (1-4).
#        - 'number of particles' (float): Number of molecules (from 'NIST_SPC_E_Water').
#        - 'box length' (float): Box dimensions (from 'NIST_SPC_E_Water').
#        - 'cutoff' (int): Fixed cutoff distance for interactions (10 Å).
#        - 'alpha' (float): Ewald summation parameter (5.6 / min(a, b, c)).
#        - 'kmax' (int): Maximum wave vector index (5); also, only include k for which k² < kmax² + 2, i.e., k² < 27.
#        - 'ε0' (float): Permittivity of Vacuum (8.854187817E-12 C²/(J m)).
#        - 'kB' (float): Boltzmann Constant (1.3806488E-23 J/K).

# 4. configuration DataFrame (from 'extracting_positions'):
#    - Created per file, containing atomic positions.
#    - Columns:
#        - 'X' (float): Atom coordinates in Ångströms.
#        - 'Y' (float): Atom coordinates in Ångströms.
#        - 'Z' (float): Atom coordinates in Ångströms.
#        - 'Atom Type' (str): Type of atom ('O' or 'H').
#        - 'Molecule' (int): Molecule index assigned based on position.


system, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties,NIST_TRICLINIC_SPC_E_Water)

# Computing energies storing in results
results = pd.DataFrame()

results['Number of Particles'] = system['number of particles'].astype(int)

# Calculate LRC energy for all system configurations
results['lrc_Energies'] = system.apply(
    lambda row: compute_lrc_energy(row, force_field), axis=1
)

# Calculate pairwise energy for all system configurations
results['dispersion_energies'] = system['file_paths'].apply(
    lambda file_path: pair_dispersion_energy(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path), 
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['real_energies'] = system['file_paths'].apply(
    lambda file_path: compute_real_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['fourier_energies'] = system['file_paths'].apply(
    lambda file_path: compute_fourier_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['self_energies'] = system['file_paths'].apply(
    lambda file_path: compute_self_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['intra_energies'] = system['file_paths'].apply(
    lambda file_path: compute_intra_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

def compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):
    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')

    matched_real = matched_fourier = matched_self = matched_intra = 0
    matched_dispersion = matched_lrc = 0
    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0
    not_matched_dispersion = not_matched_lrc = 0
    l2_dispersion = l2_lrc = l2_real = 0.0
    l2_fourier = l2_self = l2_intra = 0.0

    real_energy_output = []
    fourier_energy_output = []
    self_energy_output = []
    intra_energy_output = []
    lrc_energy_output = []
    dispersion_energy_output = []

    for idx, row in df_merged.iterrows():
        real_energy = row['real_energies']
        fourier_energy = row['fourier_energies']
        self_energy = row['self_energies']
        intra_energy = row['intra_energies']
        num_molecules = row['Number of Particles']
        lrc_energy = row['lrc_Energies']
        dispersion_energy = row['dispersion_energies']

        if pd.isna(row['Ereal/kB (K)']):
            continue
        nist_real_energy = float(row['Ereal/kB (K)'])
        nist_fourier_energy = float(row['Efourier/kB (K)'])
        nist_self_energy = float(row['Eself/kB (K)'])
        nist_intra_energy = float(row['Eintra/kB (K)'])
        nist_lrc_energy = float(row['ELRC/kB (K)'])
        nist_dispersion_energy = float(row['Edisp/kB (K)'])

        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)
        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)
        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)
        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)
        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)
        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)

        matched_real += int(match_real)
        not_matched_real += int(not match_real)
        matched_fourier += int(match_fourier)
        not_matched_fourier += int(not match_fourier)
        matched_self += int(match_self)
        not_matched_self += int(not match_self)
        matched_intra += int(match_intra)
        not_matched_intra += int(not match_intra)
        matched_dispersion += int(match_dispersion)
        not_matched_dispersion += int(not match_dispersion)
        matched_lrc += int(match_lrc)
        not_matched_lrc += int(not match_lrc)

        dispersion_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}"")
        lrc_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}"")
        real_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}"")
        fourier_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}"")
        self_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}"")
        intra_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}"")

        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)
        l2_lrc = np.square(lrc_energy - nist_lrc_energy)
        l2_real = np.square(real_energy - nist_real_energy)
        l2_fourier = np.square(fourier_energy - nist_fourier_energy)
        l2_self = np.square(self_energy - nist_self_energy)
        l2_intra = np.square(intra_energy - nist_intra_energy)

    print()
    print(""Lennard-Jones Pair Dispersion Energy Comparison:"")
    print(*dispersion_energy_output)
    print(""Lennard-Jones long-range corrections Energy Comparison:"")
    print(*lrc_energy_output)
    print(""Real Energy Comparison:"")
    print(*real_energy_output)
    print(""Fourier Energy Comparison:"")
    print(*fourier_energy_output)
    print(""Self Energy Comparison:"")
    print(*self_energy_output)
    print(""Intra Energy Comparison:"")
    print(*intra_energy_output)
    print()
    print(f""Count of correct pairwise answers: {matched_dispersion}"")
    print(f""Count of incorrect pairwise answers: {not_matched_dispersion}"")
    print(f""Count of correct LRC answers: {matched_lrc}"")
    print(f""Count of incorrect LRC answers: {not_matched_lrc}"")
    print(f""Count of correct Real Energy answers: {matched_real}"")
    print(f""Count of incorrect Real Energy answers: {not_matched_real}"")
    print(f""Count of correct Fourier Energy answers: {matched_fourier}"")
    print(f""Count of incorrect Fourier Energy answers: {not_matched_fourier}"")
    print(f""Count of correct Self Energy answers: {matched_self}"")
    print(f""Count of incorrect Self Energy answers: {not_matched_self}"")
    print(f""Count of correct Intra Energy answers: {matched_intra}"")
    print(f""Count of incorrect Intra Energy answers: {not_matched_intra}"")
    print()
    print(f""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}"")
    print(f""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}"")
    print(f""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}"")
    print(f""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}"")
    print(f""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}"")
    print(f""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}"")
    print(f""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}"")
    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc
    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc
    print(f""Total correct answers: {total_correct}"")
    print(f""Total incorrect answers: {total_incorrect}"")


# calling compare_coulomb_energy function
compare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)


Context:
Illustration of input file format:

            3.000000000000e+01       3.000000000000e+01       3.000000000000e+01
            8.500000000000e+01       7.500000000000e+01       8.000000000000e+01
         200
    1      -1.073606597760e+01       1.432194046140e+01      -6.226901963110e+00    O
    2      -1.661030970030e+01      -1.461065205480e+01      -5.798020258290e+00    H
    3      -1.118063417070e+01       1.380841402440e+01      -6.960829561930e+00    H
    4      -1.377161709910e+01      -8.711236583990e+00      -1.350200277380e+01    O
    5      -1.347193958490e+01      -8.247621904110e+00      -1.433582218840e+01    H
   
Formula for the potential energy for the SPC/E model of water(latex form):

\Large E_{total}\left( \mathbf{r}^N \right) = E_{disp}\left( \mathbf{r}^N \right) + E_{LRC} + E_{coulomb}\left( \mathbf{r}^N \right)

The terms on the right-hand side of the equality to be computed are:

1) The pair dispersion energy

2) The long-range correction to the pair dispersion energy

3) The Coulombic potential energy

Formula for the Coulombic potential energy(latex form):

\Large \begin{eqnarray} E_{coulomb}\left(\mathbf{r}^N\right) & = &
\sum\limits_{j}  \sum\limits_{l>j}
\dfrac{q_j q_l}{ 4 \pi \epsilon_0} \dfrac{\text{erfc}\left(\alpha \cdot  \left| \mathbf{r}_{jl} \right| \right)}{\left| \mathbf{r}_{jl} \right|} \Theta\left( r_{cut} - \left|\mathbf{r}_{jl}\right| \right) \\
&& +\dfrac{1}{2 \pi V} \sum\limits_{\mathbf{k} \neq \mathbf{0}} \dfrac{1}{k^2} \exp \left[-\left( \dfrac{\pi k}{\alpha} \right)^2 \right] \dfrac{1}{4 \pi \epsilon_0} \cdot \left|\sum\limits_{j=1}^N q_j \exp \left(2\pi i \mathbf{k} \cdot \mathbf{r}_j \right) \right|^2 \\
&& - \dfrac{\alpha}{\sqrt{\pi}} \sum\limits_j \dfrac{q_j^2}{4 \pi \epsilon_0} \\
&& - \sum\limits_{j=1}^M  \sum\limits_{\kappa}  \sum\limits_{\lambda>\kappa} \dfrac{q_{j_\kappa} q_{j_\lambda}}{ 4 \pi \epsilon_0} \dfrac{\text{erf}\left(\alpha \cdot  \left| \mathbf{r}_{j_\kappa j_\lambda} \right| \right)}{\left| \mathbf{r}_{j_\kappa j_\lambda} \right|}
\end{eqnarray}

The Coulombic energy is computed using the Ewald Summation Method. The terms on the right hand side of the equality are

1) The real-space term Ereal,

2) The Fourier-space term, Efourier,

3) The self-correction term Eself,

4) The intramolecular term Eintra.

Primary task:

Modify the functions in the code above, considering the input format.

Incorporate any additional functions that might be required.

Make the necessary changes to the dataframes to accommodate the updated input format.

You may access the required columns from the given dataframes as parameters to the function to calculate the energies.

You may modify other parts of the code, except the compare_LJ_coulomb_energy function.

Strict Requirements:

Do not modify the function names or parameters.

The output should always include Python code for modifying the respective functions.

The compare_LJ_coulomb_energy function should remain unchanged, as it controls the iteration loop.

Ensure that the print statements in the compare_LJ_coulomb_energy function remain exactly as they are, even as you make modifications to the other functions.

Iteration Notes: 

If multiple functions are provided to solve the task, work through them one by one in each iteration.

The iteration loop will continue until the desired outcome is achieved.

Output Format:

Produce a JSON output in the following format:
  ""Reasoning"": """",
  ""Code"": """"

Ensure that:
1. The JSON output is **properly formatted** with **double quotes** around keys.
2. The **Reasoning** section provides a concise and clear explanation of the approach taken.
3. The **Code** section contains well-structured, indented, and syntactically correct Python (or the required language).
4. The JSON output does **not** contain extraneous symbols such as triple backticks (` ``` `) or markdown indicators.
5. The output should be **fully valid JSON** and parseable using `json.loads()`.

Feedback Integration: 

When feedback is provided, ensure you proceed with the next steps based on the iteration results and the correct answers generated. Focus on the L2 score to reduce errors.


","{
  ""Reasoning"": ""To accommodate triclinic boxes directly from the updated file format, the extracting_positions function now parses the first three lines for (a, b, c), (α, β, γ), and the number of molecules (M). It then reads atomic coordinates from subsequent lines. In creating_dataframes, the code is modified so that the box parameters and M are taken from extracting_positions rather than from the NIST_SPC_E_Water DataFrame, although the latter remains for energy comparisons. The compare_LJ_coulomb_energy function is left unchanged to handle outputs and comparisons."",
  ""Code"": ""import numpy as np\nimport pandas as pd\nfrom scipy.special import erfc, erf\nimport math\n\n# defining all variables\natom_properties = {\n    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},\n    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},\n}\n\nfile_paths = [\n    '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'\n]\n\nNIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],\n 'M (number of SPC/E molecules)': [400, 300, 200, 100],\n 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],\n 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',\n  '[27 Å, 30 Å, 36 Å]',\n  '[30 Å, 30 Å, 30 Å]',\n  '[36 Å, 36 Å, 36 Å]'],\n 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',\n  '[90°, 75°, 90°]',\n  '[85°, 75°, 80°]',\n  '[90°, 60°, 90°]'],\n 'Number of Wave Vectors': [831, 1068, 838, 1028],\n 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],\n 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],\n 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],\n 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],\n 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],\n 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],\n 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}\n\n# 1) Updated extracting_positions to parse triclinic box input \n\ndef extracting_positions(input_file):\n    with open(input_file, \""r\"") as file:\n        lines = file.readlines()\n\n    # Parse first three lines for box and molecule info\n    # Example:\n    # line[0]:  3.000000000000e+01 3.000000000000e+01 3.000000000000e+01\n    # line[1]:  8.500000000000e+01 7.500000000000e+01 8.000000000000e+01\n    # line[2]:  200\n\n    line0 = lines[0].split()\n    a, b, c = float(line0[0]), float(line0[1]), float(line0[2])\n\n    line1 = lines[1].split()\n    alpha_deg, beta_deg, gamma_deg = float(line1[0]), float(line1[1]), float(line1[2])\n\n    line2 = lines[2].split()\n    M = int(line2[0])\n\n    data_list = []\n    # Remaining lines contain ID, X, Y, Z, Atom Type\n    for line in lines[3:]:\n        parts = line.strip().split()\n        if len(parts) >= 5:\n            try:\n                x, y, z = map(float, parts[1:4])\n                atom_type = parts[4]\n                data_list.append([x, y, z, atom_type])\n            except ValueError:\n                continue\n\n    # Create a DataFrame for coordinates\n    configuration = pd.DataFrame(data_list, columns=[\""X\"", \""Y\"", \""Z\"", \""Atom Type\""])\n    configuration.index = range(1, len(configuration) + 1)\n\n    # Simple molecule indexing (3 atoms per water molecule in SPC/E)\n    configuration[\""Molecule\""] = ((configuration.index - 1) // 3) + 1\n\n    # Store box info as attributes\n    configuration.attrs[\""a\""] = a\n    configuration.attrs[\""b\""] = b\n    configuration.attrs[\""c\""] = c\n    configuration.attrs[\""alpha_deg\""] = alpha_deg\n    configuration.attrs[\""beta_deg\""] = beta_deg\n    configuration.attrs[\""gamma_deg\""] = gamma_deg\n    configuration.attrs[\""M\""] = M\n\n    return configuration\n\n# 2) We now create system DataFrame based on file inputs, ignoring old parse_cell_sides logic.\n\ndef creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):\n    # We keep NIST_SPC_E_Water for final comparison, but for the system DataFrame\n    # we parse a,b,c, angles, and M directly from the file.\n\n    # Summation of energies from NIST data\n    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)\n    NIST_SPC_E_Water['Sum of energies'] = (\n        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +\n        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +\n        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']\n    )\n\n    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')\n\n    # Build system from file data\n    system_rows = []\n    for file_path in file_paths:\n        config_temp = extracting_positions(file_path)\n        a = config_temp.attrs[\""a\""]\n        b = config_temp.attrs[\""b\""]\n        c = config_temp.attrs[\""c\""]\n        alpha_deg = config_temp.attrs[\""alpha_deg\""]\n        beta_deg = config_temp.attrs[\""beta_deg\""]\n        gamma_deg = config_temp.attrs[\""gamma_deg\""]\n        M = config_temp.attrs[\""M\""]\n\n        # For the 'configuration #' we can extract from the filename or default to 0\n        # We'll do quick extract from filename\n        import re\n        match_conf = re.search(r'(\\d+)', file_path)\n        conf_num = int(match_conf.group(1)) if match_conf else 0\n\n        system_dict = {\n            \""file_paths\"": file_path,\n            \""configuration #\"": conf_num,\n            \""number of particles\"": float(M),\n            \""a\"": a,\n            \""b\"": b,\n            \""c\"": c,\n            \""alpha_deg\"": alpha_deg,\n            \""beta_deg\"": beta_deg,\n            \""gamma_deg\"": gamma_deg\n        }\n        system_rows.append(system_dict)\n\n    system = pd.DataFrame(system_rows)\n\n    # Fixed cutoff\n    system['cutoff'] = 10.0\n\n    # Ewald alpha\n    def alpha_value(row):\n        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28\n\n    system['alpha'] = system.apply(alpha_value, axis=1)\n\n    # wave vectors\n    system['kmax'] = 5\n    system['ε0'] = float(8.854187817E-12)\n    system['kB'] = float(1.3806488E-23)\n\n    return system, force_field, NIST_SPC_E_Water\n\n# pairwise dispersion energy functions\n\ndef build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):\n    alpha = math.radians(alpha_deg)\n    beta = math.radians(beta_deg)\n    gamma = math.radians(gamma_deg)\n\n    ax = a\n    ay = 0.0\n    az = 0.0\n\n    bx = b * math.cos(gamma)\n    by = b * math.sin(gamma)\n    bz = 0.0\n\n    sin_gamma = math.sin(gamma)\n    cx = c * math.cos(beta)\n    if abs(sin_gamma) < 1e-14:\n        sin_gamma = 1e-14\n    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)\n    cz = math.sqrt(c**2 - cx**2 - cy**2)\n\n    h = np.array([\n        [ax, bx, cx],\n        [ay, by, cy],\n        [az, bz, cz]\n    ], dtype=float)\n\n    h_inv = np.linalg.inv(h)\n    return h, h_inv\n\ndef min_image_distance_triclinic(r_ij, h, h_inv):\n    frac = h_inv.dot(r_ij)\n    frac -= np.round(frac)\n    return h.dot(frac)\n\n# Pairwise dispersion energy\n\ndef pair_dispersion_energy(system_data, configuration, force_field):\n    positions = configuration[['X', 'Y', 'Z']].values\n    atom_types = configuration['Atom Type'].values\n    cutoff = system_data['cutoff']\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n\n    total_dispersion_energy = 0.0\n    num_atoms = len(positions)\n\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            r_ij = positions[i] - positions[j]\n            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)\n            distance = np.linalg.norm(r_ij)\n\n            if 0 < distance < cutoff:\n                type_i = atom_types[i]\n                type_j = atom_types[j]\n                if type_i not in force_field.index or type_j not in force_field.index:\n                    continue\n\n                epsilon_i = force_field.loc[type_i, 'epsilon']\n                epsilon_j = force_field.loc[type_j, 'epsilon']\n                sigma_i = force_field.loc[type_i, 'sigma']\n                sigma_j = force_field.loc[type_j, 'sigma']\n\n                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)\n                sigma_ij = 0.5 * (sigma_i + sigma_j)\n                s_over_r = sigma_ij / distance\n                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)\n                total_dispersion_energy += lj_pot\n\n    return total_dispersion_energy\n\n# Compute LRC energy\n\ndef compute_lrc_energy(system_row, force_field):\n    U_lrc_total = 0.0\n    cutoff = system_row['cutoff']\n\n    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],\n                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])\n    volume = abs(np.linalg.det(h))\n\n    for atom_type, atom_data in force_field.iterrows():\n        num_particles = system_row['number of particles'] * atom_data['num_particles']\n        rho = num_particles / volume\n        sigma = atom_data['sigma']\n        epsilon = atom_data['epsilon']\n\n        if cutoff > 0:\n            sc3 = (sigma / cutoff)**3\n            sc9 = sc3**3\n        else:\n            sc3, sc9 = 0.0, 0.0\n\n        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)\n        U_lrc *= num_particles\n        U_lrc_total += U_lrc\n\n    return U_lrc_total\n\n# Compute real energies\n\ndef compute_real_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data[\""alpha\""]\n    cutoff = system_data[\""cutoff\""]\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n\n    positions = configuration[[\""X\"", \""Y\"", \""Z\""]].values\n    atom_types = configuration[\""Atom Type\""].values\n    mol_ids = configuration[\""Molecule\""].values\n    charges = np.array([force_field.loc[t, \""charge\""] for t in atom_types])\n\n    real_energy = 0.0\n    n_atoms = len(positions)\n\n    for j in range(n_atoms - 1):\n        for l in range(j + 1, n_atoms):\n            if mol_ids[j] == mol_ids[l]:\n                continue\n            r_ij = positions[l] - positions[j]\n            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)\n            distance = np.linalg.norm(r_ij)\n            if 1e-14 < distance < cutoff:\n                q_j = charges[j]*e_charge\n                q_l = charges[l]*e_charge\n                r_m = distance*1e-10\n                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)\n\n    return real_energy\n\n# Compute Fourier energies\n\ndef compute_fourier_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data[\""alpha\""]\n    kmax = system_data[\""kmax\""]\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n    V_m = abs(np.linalg.det(h))*(1e-10**3)\n\n    positions = configuration[[\""X\"", \""Y\"", \""Z\""]].values\n    atom_types = configuration[\""Atom Type\""].values\n    charges = np.array([force_field.loc[t, \""charge\""] for t in atom_types])\n    charges_c = charges*e_charge\n\n    positions_m = positions*1e-10\n    prefactor = coulomb_factor/(2.0*V_m)\n\n    alpha_m = alpha*1e10\n    fourier_energy = 0.0\n\n    max_sq = kmax*kmax + 2\n    L_avg = (a + b + c)/3.0\n    kfactor = 2.0*math.pi/(L_avg*1e-10)\n\n    for kx in range(-kmax, kmax+1):\n        for ky in range(-kmax, kmax+1):\n            for kz in range(-kmax, kmax+1):\n                if (kx == 0 and ky == 0 and kz == 0):\n                    continue\n                if (kx*kx + ky*ky + kz*kz) >= max_sq:\n                    continue\n\n                kx_m = kfactor*kx\n                ky_m = kfactor*ky\n                kz_m = kfactor*kz\n                k_sq = kx_m**2 + ky_m**2 + kz_m**2\n                if k_sq < 1e-14:\n                    continue\n\n                real_part = 0.0\n                imag_part = 0.0\n                for j, (xj, yj, zj) in enumerate(positions_m):\n                    kr = kx_m*xj + ky_m*yj + kz_m*zj\n                    real_part += charges_c[j]*math.cos(kr)\n                    imag_part += charges_c[j]*math.sin(kr)\n\n                sk_sq = real_part**2 + imag_part**2\n                exp_factor = math.exp(-k_sq/(4.0*(alpha_m**2)))\n\n                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq\n                fourier_energy += term\n\n    return fourier_energy\n\n# Compute self energies\n\ndef compute_self_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n    atom_types = configuration['Atom Type'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n    charges_c = charges*e_charge\n\n    alpha_m = alpha*1e10\n    sum_q2 = np.sum(charges_c**2)\n\n    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2\n    return self_energy\n\n# Compute intramolecular energies\n\ndef compute_intra_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n\n    positions = configuration[[\""X\"", \""Y\"", \""Z\""]].values\n    atom_types = configuration['Atom Type'].values\n    mol_ids = configuration['Molecule'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n\n    unique_mols = np.unique(mol_ids)\n    intra_energy = 0.0\n\n    for m_id in unique_mols:\n        idxs = np.where(mol_ids == m_id)[0]\n        for i in range(len(idxs) - 1):\n            for j in range(i + 1, len(idxs)):\n                idx_i = idxs[i]\n                idx_j = idxs[j]\n                dx = positions[idx_j, 0] - positions[idx_i, 0]\n                dy = positions[idx_j, 1] - positions[idx_i, 1]\n                dz = positions[idx_j, 2] - positions[idx_i, 2]\n                r = math.sqrt(dx**2 + dy**2 + dz**2)\n                if r > 1e-14:\n                    q_i = charges[idx_i]*e_charge\n                    q_j = charges[idx_j]*e_charge\n                    r_m = r*1e-10\n                    erf_val = erf(alpha*r)\n                    # negative sign for intramolecular\n                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val\n                    intra_energy -= val\n\n    return intra_energy\n\n# Building dataframes and computing energies\nsystem, force_field, NIST_SPC_E_Water = creating_dataframes(file_paths, atom_properties, NIST_TRICLINIC_SPC_E_Water)\n\nresults = pd.DataFrame()\nresults['Number of Particles'] = system['number of particles'].astype(int)\n\nresults['lrc_Energies'] = system.apply(\n    lambda row: compute_lrc_energy(row, force_field), axis=1\n)\n\nresults['dispersion_energies'] = system['file_paths'].apply(\n    lambda file_path: pair_dispersion_energy(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path), \n        force_field\n    )\n)\n\nresults['real_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_real_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['fourier_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_fourier_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['self_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_self_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['intra_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_intra_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\n# Comparison function remains unchanged.\ndef compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):\n    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')\n\n    matched_real = matched_fourier = matched_self = matched_intra = 0\n    matched_dispersion = matched_lrc = 0\n    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0\n    not_matched_dispersion = not_matched_lrc = 0\n    l2_dispersion = l2_lrc = l2_real = 0.0\n    l2_fourier = l2_self = l2_intra = 0.0\n\n    real_energy_output = []\n    fourier_energy_output = []\n    self_energy_output = []\n    intra_energy_output = []\n    lrc_energy_output = []\n    dispersion_energy_output = []\n\n    for idx, row in df_merged.iterrows():\n        real_energy = row['real_energies']\n        fourier_energy = row['fourier_energies']\n        self_energy = row['self_energies']\n        intra_energy = row['intra_energies']\n        num_molecules = row['Number of Particles']\n        lrc_energy = row['lrc_Energies']\n        dispersion_energy = row['dispersion_energies']\n\n        if pd.isna(row['Ereal/kB (K)']):\n            continue\n        nist_real_energy = float(row['Ereal/kB (K)'])\n        nist_fourier_energy = float(row['Efourier/kB (K)'])\n        nist_self_energy = float(row['Eself/kB (K)'])\n        nist_intra_energy = float(row['Eintra/kB (K)'])\n        nist_lrc_energy = float(row['ELRC/kB (K)'])\n        nist_dispersion_energy = float(row['Edisp/kB (K)'])\n\n        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)\n        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)\n        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)\n        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)\n        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)\n        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)\n\n        matched_real += int(match_real)\n        not_matched_real += int(not match_real)\n        matched_fourier += int(match_fourier)\n        not_matched_fourier += int(not match_fourier)\n        matched_self += int(match_self)\n        not_matched_self += int(not match_self)\n        matched_intra += int(match_intra)\n        not_matched_intra += int(not match_intra)\n        matched_dispersion += int(match_dispersion)\n        not_matched_dispersion += int(not match_dispersion)\n        matched_lrc += int(match_lrc)\n        not_matched_lrc += int(not match_lrc)\n\n        dispersion_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}\"")\n        lrc_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}\"")\n        real_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}\"")\n        fourier_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}\"")\n        self_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}\"")\n        intra_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}\"")\n\n        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)\n        l2_lrc = np.square(lrc_energy - nist_lrc_energy)\n        l2_real = np.square(real_energy - nist_real_energy)\n        l2_fourier = np.square(fourier_energy - nist_fourier_energy)\n        l2_self = np.square(self_energy - nist_self_energy)\n        l2_intra = np.square(intra_energy - nist_intra_energy)\n\n    print()\n    print(\""Lennard-Jones Pair Dispersion Energy Comparison:\"")\n    print(*dispersion_energy_output)\n    print(\""Lennard-Jones long-range corrections Energy Comparison:\"")\n    print(*lrc_energy_output)\n    print(\""Real Energy Comparison:\"")\n    print(*real_energy_output)\n    print(\""Fourier Energy Comparison:\"")\n    print(*fourier_energy_output)\n    print(\""Self Energy Comparison:\"")\n    print(*self_energy_output)\n    print(\""Intra Energy Comparison:\"")\n    print(*intra_energy_output)\n    print()\n    print(f\""Count of correct pairwise answers: {matched_dispersion}\"")\n    print(f\""Count of incorrect pairwise answers: {not_matched_dispersion}\"")\n    print(f\""Count of correct LRC answers: {matched_lrc}\"")\n    print(f\""Count of incorrect LRC answers: {not_matched_lrc}\"")\n    print(f\""Count of correct Real Energy answers: {matched_real}\"")\n    print(f\""Count of incorrect Real Energy answers: {not_matched_real}\"")\n    print(f\""Count of correct Fourier Energy answers: {matched_fourier}\"")\n    print(f\""Count of incorrect Fourier Energy answers: {not_matched_fourier}\"")\n    print(f\""Count of correct Self Energy answers: {matched_self}\"")\n    print(f\""Count of incorrect Self Energy answers: {not_matched_self}\"")\n    print(f\""Count of correct Intra Energy answers: {matched_intra}\"")\n    print(f\""Count of incorrect Intra Energy answers: {not_matched_intra}\"")\n    print()\n    print(f\""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}\"")\n    print(f\""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}\"")\n    print(f\""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}\"")\n    print(f\""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}\"")\n    print(f\""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}\"")\n    print(f\""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}\"")\n    print(f\""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}\"")\n    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc\n    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc\n    print(f\""Total correct answers: {total_correct}\"")\n    print(f\""Total incorrect answers: {total_incorrect}\"")\n\ncompare_LJ_coulomb_energy(results, NIST_SPC_E_Water)\n""
}","import numpy as np
import pandas as pd
from scipy.special import erfc,erf
import math 

# defining all variables
atom_properties = {
    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},
    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},
}

# Trying for small configurations first
file_paths = [
    #    '../data/spce_sample_config_periodic4.txt',
    #    '../data/spce_sample_config_periodic2.txt',
    #    '../data/spce_sample_config_periodic3.txt',
        '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'
    ]

NIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],
 'M (number of SPC/E molecules)': [400, 300, 200, 100],
 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],
 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',
  '[27 Å, 30 Å, 36 Å]',
  '[30 Å, 30 Å, 30 Å]',
  '[36 Å, 36 Å, 36 Å]'],
 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',
  '[90°, 75°, 90°]',
  '[85°, 75°, 80°]',
  '[90°, 60°, 90°]'],
 'Number of Wave Vectors': [831, 1068, 838, 1028],
 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],
 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],
 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],
 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],
 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],
 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],
 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}

# Data processing





def extracting_positions(input_file):
        # Extract the positions from the .xyz file
    with open(input_file, ""r"") as file:
        lines = file.readlines()

    data_lines = lines[2:]

    data_list = []
    for line in data_lines:
        stripped_line = line.strip()
        parts = stripped_line.split()
        if len(parts) >= 5:  
            try:
                x, y, z = map(float, parts[1:4])
                atom_type = parts[4]
                data_list.append([x, y, z, atom_type])
            except ValueError:
                continue  

    # Create a DataFrame with all configurations
    columns = [""X"", ""Y"", ""Z"", ""Atom Type""]
    configuration = pd.DataFrame(data_list, columns=columns)

    configuration.index = range(1, len(configuration) + 1)

    configuration[""Molecule""] = ((configuration.index - 1) // 3) + 1
    
    return configuration

# create the target dataframes
def parse_cell_sides(sides_str):
    sides_str = sides_str.strip().strip('[]')
    parts = sides_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('Å', '')
        values.append(float(p))
    return values

def parse_cell_angles(angles_str):
    angles_str = angles_str.strip().strip('[]')
    parts = angles_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('°', '')
        values.append(float(p))
    return values

def creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):
    # We keep NIST_SPC_E_Water for final comparison, but for the system DataFrame
    # we parse a,b,c, angles, and M directly from the file.

    # Summation of energies from NIST data
    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)
    NIST_SPC_E_Water['Sum of energies'] = (
        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +
        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +
        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']
    )

    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')

    # Build system from file data
    system_rows = []
    for file_path in file_paths:
        config_temp = extracting_positions(file_path)
        a = config_temp.attrs[""a""]
        b = config_temp.attrs[""b""]
        c = config_temp.attrs[""c""]
        alpha_deg = config_temp.attrs[""alpha_deg""]
        beta_deg = config_temp.attrs[""beta_deg""]
        gamma_deg = config_temp.attrs[""gamma_deg""]
        M = config_temp.attrs[""M""]

        # For the 'configuration #' we can extract from the filename or default to 0
        # We'll do quick extract from filename
        import re
        match_conf = re.search(r'(\d+)', file_path)
        conf_num = int(match_conf.group(1)) if match_conf else 0

        system_dict = {
            ""file_paths"": file_path,
            ""configuration #"": conf_num,
            ""number of particles"": float(M),
            ""a"": a,
            ""b"": b,
            ""c"": c,
            ""alpha_deg"": alpha_deg,
            ""beta_deg"": beta_deg,
            ""gamma_deg"": gamma_deg
        }
        system_rows.append(system_dict)

    system = pd.DataFrame(system_rows)

    # Fixed cutoff
    system['cutoff'] = 10.0

    # Ewald alpha
    def alpha_value(row):
        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28

    system['alpha'] = system.apply(alpha_value, axis=1)

    # wave vectors
    system['kmax'] = 5
    system['ε0'] = float(8.854187817E-12)
    system['kB'] = float(1.3806488E-23)

    return system, force_field, NIST_SPC_E_Water

# pairwise dispersion energy functions

# Minimum Image Distance function and Pair Dispersion Energy calculation (Code 3)
def minimum_image_distance(r_ij, cell_length):
    # Apply the minimum image convention to distances.
    return r_ij - cell_length * np.round(r_ij / cell_length)

# pairwise dispersion energy operation
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def pair_dispersion_energy(system_data, configuration, force_field):
    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    total_dispersion_energy = 0.0
    num_atoms = len(positions)

    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            r_ij = positions[i] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)

            if 0 < distance < cutoff:
                type_i = atom_types[i]
                type_j = atom_types[j]
                if type_i not in force_field.index or type_j not in force_field.index:
                    continue

                epsilon_i = force_field.loc[type_i, 'epsilon']
                epsilon_j = force_field.loc[type_j, 'epsilon']
                sigma_i = force_field.loc[type_i, 'sigma']
                sigma_j = force_field.loc[type_j, 'sigma']

                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)
                sigma_ij = 0.5 * (sigma_i + sigma_j)
                s_over_r = sigma_ij / distance
                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)
                total_dispersion_energy += lj_pot

    return total_dispersion_energy

# Compute LRC energy
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_lrc_energy(system_row, force_field):
    U_lrc_total = 0.0
    cutoff = system_row['cutoff']

    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],
                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])
    volume = abs(np.linalg.det(h))

    for atom_type, atom_data in force_field.iterrows():
        num_particles = system_row['number of particles'] * atom_data['num_particles']
        rho = num_particles / volume
        sigma = atom_data['sigma']
        epsilon = atom_data['epsilon']

        if cutoff > 0:
            sc3 = (sigma / cutoff)**3
            sc9 = sc3**3
        else:
            sc3, sc9 = 0.0, 0.0

        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)
        U_lrc *= num_particles
        U_lrc_total += U_lrc

    return U_lrc_total

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def compute_real_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    cutoff = system_data[""cutoff""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    mol_ids = configuration[""Molecule""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])

    real_energy = 0.0
    n_atoms = len(positions)

    for j in range(n_atoms - 1):
        for l in range(j + 1, n_atoms):
            if mol_ids[j] == mol_ids[l]:
                continue
            r_ij = positions[l] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)
            if 1e-14 < distance < cutoff:
                q_j = charges[j]*e_charge
                q_l = charges[l]*e_charge
                r_m = distance*1e-10
                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)

    return real_energy

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_fourier_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    kmax = system_data[""kmax""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)
    V_m = abs(np.linalg.det(h))*(1e-10**3)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])
    charges_c = charges*e_charge

    positions_m = positions*1e-10
    prefactor = coulomb_factor/(2.0*V_m)

    alpha_m = alpha*1e10
    fourier_energy = 0.0

    max_sq = kmax*kmax + 2
    L_avg = (a + b + c)/3.0
    kfactor = 2.0*math.pi/(L_avg*1e-10)

    for kx in range(-kmax, kmax+1):
        for ky in range(-kmax, kmax+1):
            for kz in range(-kmax, kmax+1):
                if (kx == 0 and ky == 0 and kz == 0):
                    continue
                if (kx*kx + ky*ky + kz*kz) >= max_sq:
                    continue

                kx_m = kfactor*kx
                ky_m = kfactor*ky
                kz_m = kfactor*kz
                k_sq = kx_m**2 + ky_m**2 + kz_m**2
                if k_sq < 1e-14:
                    continue

                real_part = 0.0
                imag_part = 0.0
                for j, (xj, yj, zj) in enumerate(positions_m):
                    kr = kx_m*xj + ky_m*yj + kz_m*zj
                    real_part += charges_c[j]*math.cos(kr)
                    imag_part += charges_c[j]*math.sin(kr)

                sk_sq = real_part**2 + imag_part**2
                exp_factor = math.exp(-k_sq/(4.0*(alpha_m**2)))

                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq
                fourier_energy += term

    return fourier_energy


def compute_self_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    alpha_m = alpha*1e10
    sum_q2 = np.sum(charges_c**2)

    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2
    return self_energy


def compute_intra_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    unique_mols = np.unique(mol_ids)
    intra_energy = 0.0

    for m_id in unique_mols:
        idxs = np.where(mol_ids == m_id)[0]
        for i in range(len(idxs) - 1):
            for j in range(i + 1, len(idxs)):
                idx_i = idxs[i]
                idx_j = idxs[j]
                dx = positions[idx_j, 0] - positions[idx_i, 0]
                dy = positions[idx_j, 1] - positions[idx_i, 1]
                dz = positions[idx_j, 2] - positions[idx_i, 2]
                r = math.sqrt(dx**2 + dy**2 + dz**2)
                if r > 1e-14:
                    q_i = charges[idx_i]*e_charge
                    q_j = charges[idx_j]*e_charge
                    r_m = r*1e-10
                    erf_val = erf(alpha*r)
                    # negative sign for intramolecular
                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val
                    intra_energy -= val

    return intra_energy


# DataFrame Descriptions:

# 1. NIST_TRICLINIC_SPC_E_Water DataFrame:
#    - Contains thermodynamic properties of SPC/E water configurations in both triclinic and monoclinic cells.
#    - Columns:
#        - 'Configuration' (int): Configuration ID (1-4).
#        - 'M (number of SPC/E molecules)' (int): Number of SPC/E molecules in the system.
#        - 'Cell Type' (str): Type of the cell (e.g., Triclinic, Monoclinic).
#        - 'Cell Side Lengths [a, b, c] (Å)' (list of strings): Cell side lengths in Ångströms.
#        - 'Cell Angles [α, β, γ] (degrees)' (list of strings): Cell angles in degrees.
#        - 'Number of Wave Vectors' (int): The number of wave vectors for each configuration.
#        - 'Edisp/kB (K)' (float): Dispersion energy in Kelvin.
#        - 'ELRC/kB (K)' (float): Long-range correction energy in Kelvin.
#        - 'Ereal/kB (K)' (float): Real energy in Kelvin.
#        - 'Efourier/kB (K)' (float): Fourier transform energy in Kelvin.
#        - 'Eself/kB (K)' (float): Self-interaction energy in Kelvin.
#        - 'Eintra/kB (K)' (float): Intra-molecular energy in Kelvin.
#        - 'Etotal/kB (K)' (float): Total energy in Kelvin.

# 2. force_field DataFrame:
#    - Contains force field parameters for SPC/E water, specifically for oxygen ('O') and hydrogen ('H').
#    - Columns:
#        - 'type' (str): Atom type ('O' or 'H').
#        - 'sigma' (float): Lennard-Jones parameter (Å).
#        - 'epsilon' (float): Lennard-Jones well depth (K).
#        - 'charge' (float): Partial charge (e).
#        - 'num_particles' (int): Number of particles per molecule.

# 3. system DataFrame:
#    - Contains metadata about each system configuration.
#    - Columns:
#        - 'file_paths' (str): File names containing atomic configurations.
#        - 'configuration #' (int): Extracted configuration number (1-4).
#        - 'number of particles' (float): Number of molecules (from 'NIST_SPC_E_Water').
#        - 'box length' (float): Box dimensions (from 'NIST_SPC_E_Water').
#        - 'cutoff' (int): Fixed cutoff distance for interactions (10 Å).
#        - 'alpha' (float): Ewald summation parameter (5.6 / min(a, b, c)).
#        - 'kmax' (int): Maximum wave vector index (5); also, only include k for which k² < kmax² + 2, i.e., k² < 27.
#        - 'ε0' (float): Permittivity of Vacuum (8.854187817E-12 C²/(J m)).
#        - 'kB' (float): Boltzmann Constant (1.3806488E-23 J/K).

# 4. configuration DataFrame (from 'extracting_positions'):
#    - Created per file, containing atomic positions.
#    - Columns:
#        - 'X' (float): Atom coordinates in Ångströms.
#        - 'Y' (float): Atom coordinates in Ångströms.
#        - 'Z' (float): Atom coordinates in Ångströms.
#        - 'Atom Type' (str): Type of atom ('O' or 'H').
#        - 'Molecule' (int): Molecule index assigned based on position.


system, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties,NIST_TRICLINIC_SPC_E_Water)

# Computing energies storing in results
results = pd.DataFrame()

results['Number of Particles'] = system['number of particles'].astype(int)

# Calculate LRC energy for all system configurations
results['lrc_Energies'] = system.apply(
    lambda row: compute_lrc_energy(row, force_field), axis=1
)

# Calculate pairwise energy for all system configurations
results['dispersion_energies'] = system['file_paths'].apply(
    lambda file_path: pair_dispersion_energy(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path), 
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['real_energies'] = system['file_paths'].apply(
    lambda file_path: compute_real_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['fourier_energies'] = system['file_paths'].apply(
    lambda file_path: compute_fourier_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['self_energies'] = system['file_paths'].apply(
    lambda file_path: compute_self_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['intra_energies'] = system['file_paths'].apply(
    lambda file_path: compute_intra_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

def compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):
    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')

    matched_real = matched_fourier = matched_self = matched_intra = 0
    matched_dispersion = matched_lrc = 0
    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0
    not_matched_dispersion = not_matched_lrc = 0
    l2_dispersion = l2_lrc = l2_real = 0.0
    l2_fourier = l2_self = l2_intra = 0.0

    real_energy_output = []
    fourier_energy_output = []
    self_energy_output = []
    intra_energy_output = []
    lrc_energy_output = []
    dispersion_energy_output = []

    for idx, row in df_merged.iterrows():
        real_energy = row['real_energies']
        fourier_energy = row['fourier_energies']
        self_energy = row['self_energies']
        intra_energy = row['intra_energies']
        num_molecules = row['Number of Particles']
        lrc_energy = row['lrc_Energies']
        dispersion_energy = row['dispersion_energies']

        if pd.isna(row['Ereal/kB (K)']):
            continue
        nist_real_energy = float(row['Ereal/kB (K)'])
        nist_fourier_energy = float(row['Efourier/kB (K)'])
        nist_self_energy = float(row['Eself/kB (K)'])
        nist_intra_energy = float(row['Eintra/kB (K)'])
        nist_lrc_energy = float(row['ELRC/kB (K)'])
        nist_dispersion_energy = float(row['Edisp/kB (K)'])

        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)
        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)
        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)
        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)
        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)
        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)

        matched_real += int(match_real)
        not_matched_real += int(not match_real)
        matched_fourier += int(match_fourier)
        not_matched_fourier += int(not match_fourier)
        matched_self += int(match_self)
        not_matched_self += int(not match_self)
        matched_intra += int(match_intra)
        not_matched_intra += int(not match_intra)
        matched_dispersion += int(match_dispersion)
        not_matched_dispersion += int(not match_dispersion)
        matched_lrc += int(match_lrc)
        not_matched_lrc += int(not match_lrc)

        dispersion_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}"")
        lrc_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}"")
        real_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}"")
        fourier_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}"")
        self_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}"")
        intra_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}"")

        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)
        l2_lrc = np.square(lrc_energy - nist_lrc_energy)
        l2_real = np.square(real_energy - nist_real_energy)
        l2_fourier = np.square(fourier_energy - nist_fourier_energy)
        l2_self = np.square(self_energy - nist_self_energy)
        l2_intra = np.square(intra_energy - nist_intra_energy)

    print()
    print(""Lennard-Jones Pair Dispersion Energy Comparison:"")
    print(*dispersion_energy_output)
    print(""Lennard-Jones long-range corrections Energy Comparison:"")
    print(*lrc_energy_output)
    print(""Real Energy Comparison:"")
    print(*real_energy_output)
    print(""Fourier Energy Comparison:"")
    print(*fourier_energy_output)
    print(""Self Energy Comparison:"")
    print(*self_energy_output)
    print(""Intra Energy Comparison:"")
    print(*intra_energy_output)
    print()
    print(f""Count of correct pairwise answers: {matched_dispersion}"")
    print(f""Count of incorrect pairwise answers: {not_matched_dispersion}"")
    print(f""Count of correct LRC answers: {matched_lrc}"")
    print(f""Count of incorrect LRC answers: {not_matched_lrc}"")
    print(f""Count of correct Real Energy answers: {matched_real}"")
    print(f""Count of incorrect Real Energy answers: {not_matched_real}"")
    print(f""Count of correct Fourier Energy answers: {matched_fourier}"")
    print(f""Count of incorrect Fourier Energy answers: {not_matched_fourier}"")
    print(f""Count of correct Self Energy answers: {matched_self}"")
    print(f""Count of incorrect Self Energy answers: {not_matched_self}"")
    print(f""Count of correct Intra Energy answers: {matched_intra}"")
    print(f""Count of incorrect Intra Energy answers: {not_matched_intra}"")
    print()
    print(f""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}"")
    print(f""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}"")
    print(f""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}"")
    print(f""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}"")
    print(f""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}"")
    print(f""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}"")
    print(f""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}"")
    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc
    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc
    print(f""Total correct answers: {total_correct}"")
    print(f""Total incorrect answers: {total_incorrect}"")


# calling compare_coulomb_energy function
compare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)"
1,2,2025-04-03_11:28:07,o1,medium,short,"Result from the code generated:

            Your code resulted in the following error from 0 iterations. The threshold is 3. Resolve the error before the 3rd attempt:
            Error
            Traceback (most recent call last):
  File ""<string>"", line 557, in <module>
  File ""<string>"", line 110, in creating_dataframes
KeyError: 'a' 
            Review the specific part or function causing the error in the next iteration and correct it.
            ","Please find the code generated in iteration 2. You have 1 iterations remaining to complete the code for triclinic box configurations by changing the cubic box configurations.


import numpy as np
import pandas as pd
from scipy.special import erfc,erf
import math 

# defining all variables
atom_properties = {
    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},
    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},
}

# Trying for small configurations first
file_paths = [
    #    '../data/spce_sample_config_periodic4.txt',
    #    '../data/spce_sample_config_periodic2.txt',
    #    '../data/spce_sample_config_periodic3.txt',
        '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'
    ]

NIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],
 'M (number of SPC/E molecules)': [400, 300, 200, 100],
 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],
 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',
  '[27 Å, 30 Å, 36 Å]',
  '[30 Å, 30 Å, 30 Å]',
  '[36 Å, 36 Å, 36 Å]'],
 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',
  '[90°, 75°, 90°]',
  '[85°, 75°, 80°]',
  '[90°, 60°, 90°]'],
 'Number of Wave Vectors': [831, 1068, 838, 1028],
 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],
 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],
 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],
 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],
 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],
 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],
 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}

# Data processing





def extracting_positions(input_file):
        # Extract the positions from the .xyz file
    with open(input_file, ""r"") as file:
        lines = file.readlines()

    data_lines = lines[2:]

    data_list = []
    for line in data_lines:
        stripped_line = line.strip()
        parts = stripped_line.split()
        if len(parts) >= 5:  
            try:
                x, y, z = map(float, parts[1:4])
                atom_type = parts[4]
                data_list.append([x, y, z, atom_type])
            except ValueError:
                continue  

    # Create a DataFrame with all configurations
    columns = [""X"", ""Y"", ""Z"", ""Atom Type""]
    configuration = pd.DataFrame(data_list, columns=columns)

    configuration.index = range(1, len(configuration) + 1)

    configuration[""Molecule""] = ((configuration.index - 1) // 3) + 1
    
    return configuration

# create the target dataframes
def parse_cell_sides(sides_str):
    sides_str = sides_str.strip().strip('[]')
    parts = sides_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('Å', '')
        values.append(float(p))
    return values

def parse_cell_angles(angles_str):
    angles_str = angles_str.strip().strip('[]')
    parts = angles_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('°', '')
        values.append(float(p))
    return values

def creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):
    # We keep NIST_SPC_E_Water for final comparison, but for the system DataFrame
    # we parse a,b,c, angles, and M directly from the file.

    # Summation of energies from NIST data
    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)
    NIST_SPC_E_Water['Sum of energies'] = (
        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +
        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +
        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']
    )

    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')

    # Build system from file data
    system_rows = []
    for file_path in file_paths:
        config_temp = extracting_positions(file_path)
        a = config_temp.attrs[""a""]
        b = config_temp.attrs[""b""]
        c = config_temp.attrs[""c""]
        alpha_deg = config_temp.attrs[""alpha_deg""]
        beta_deg = config_temp.attrs[""beta_deg""]
        gamma_deg = config_temp.attrs[""gamma_deg""]
        M = config_temp.attrs[""M""]

        # For the 'configuration #' we can extract from the filename or default to 0
        # We'll do quick extract from filename
        import re
        match_conf = re.search(r'(\d+)', file_path)
        conf_num = int(match_conf.group(1)) if match_conf else 0

        system_dict = {
            ""file_paths"": file_path,
            ""configuration #"": conf_num,
            ""number of particles"": float(M),
            ""a"": a,
            ""b"": b,
            ""c"": c,
            ""alpha_deg"": alpha_deg,
            ""beta_deg"": beta_deg,
            ""gamma_deg"": gamma_deg
        }
        system_rows.append(system_dict)

    system = pd.DataFrame(system_rows)

    # Fixed cutoff
    system['cutoff'] = 10.0

    # Ewald alpha
    def alpha_value(row):
        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28

    system['alpha'] = system.apply(alpha_value, axis=1)

    # wave vectors
    system['kmax'] = 5
    system['ε0'] = float(8.854187817E-12)
    system['kB'] = float(1.3806488E-23)

    return system, force_field, NIST_SPC_E_Water

# pairwise dispersion energy functions

# Minimum Image Distance function and Pair Dispersion Energy calculation (Code 3)
def minimum_image_distance(r_ij, cell_length):
    # Apply the minimum image convention to distances.
    return r_ij - cell_length * np.round(r_ij / cell_length)

# pairwise dispersion energy operation
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def pair_dispersion_energy(system_data, configuration, force_field):
    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    total_dispersion_energy = 0.0
    num_atoms = len(positions)

    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            r_ij = positions[i] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)

            if 0 < distance < cutoff:
                type_i = atom_types[i]
                type_j = atom_types[j]
                if type_i not in force_field.index or type_j not in force_field.index:
                    continue

                epsilon_i = force_field.loc[type_i, 'epsilon']
                epsilon_j = force_field.loc[type_j, 'epsilon']
                sigma_i = force_field.loc[type_i, 'sigma']
                sigma_j = force_field.loc[type_j, 'sigma']

                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)
                sigma_ij = 0.5 * (sigma_i + sigma_j)
                s_over_r = sigma_ij / distance
                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)
                total_dispersion_energy += lj_pot

    return total_dispersion_energy

# Compute LRC energy
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_lrc_energy(system_row, force_field):
    U_lrc_total = 0.0
    cutoff = system_row['cutoff']

    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],
                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])
    volume = abs(np.linalg.det(h))

    for atom_type, atom_data in force_field.iterrows():
        num_particles = system_row['number of particles'] * atom_data['num_particles']
        rho = num_particles / volume
        sigma = atom_data['sigma']
        epsilon = atom_data['epsilon']

        if cutoff > 0:
            sc3 = (sigma / cutoff)**3
            sc9 = sc3**3
        else:
            sc3, sc9 = 0.0, 0.0

        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)
        U_lrc *= num_particles
        U_lrc_total += U_lrc

    return U_lrc_total

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def compute_real_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    cutoff = system_data[""cutoff""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    mol_ids = configuration[""Molecule""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])

    real_energy = 0.0
    n_atoms = len(positions)

    for j in range(n_atoms - 1):
        for l in range(j + 1, n_atoms):
            if mol_ids[j] == mol_ids[l]:
                continue
            r_ij = positions[l] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)
            if 1e-14 < distance < cutoff:
                q_j = charges[j]*e_charge
                q_l = charges[l]*e_charge
                r_m = distance*1e-10
                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)

    return real_energy

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_fourier_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    kmax = system_data[""kmax""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)
    V_m = abs(np.linalg.det(h))*(1e-10**3)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])
    charges_c = charges*e_charge

    positions_m = positions*1e-10
    prefactor = coulomb_factor/(2.0*V_m)

    alpha_m = alpha*1e10
    fourier_energy = 0.0

    max_sq = kmax*kmax + 2
    L_avg = (a + b + c)/3.0
    kfactor = 2.0*math.pi/(L_avg*1e-10)

    for kx in range(-kmax, kmax+1):
        for ky in range(-kmax, kmax+1):
            for kz in range(-kmax, kmax+1):
                if (kx == 0 and ky == 0 and kz == 0):
                    continue
                if (kx*kx + ky*ky + kz*kz) >= max_sq:
                    continue

                kx_m = kfactor*kx
                ky_m = kfactor*ky
                kz_m = kfactor*kz
                k_sq = kx_m**2 + ky_m**2 + kz_m**2
                if k_sq < 1e-14:
                    continue

                real_part = 0.0
                imag_part = 0.0
                for j, (xj, yj, zj) in enumerate(positions_m):
                    kr = kx_m*xj + ky_m*yj + kz_m*zj
                    real_part += charges_c[j]*math.cos(kr)
                    imag_part += charges_c[j]*math.sin(kr)

                sk_sq = real_part**2 + imag_part**2
                exp_factor = math.exp(-k_sq/(4.0*(alpha_m**2)))

                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq
                fourier_energy += term

    return fourier_energy


def compute_self_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    alpha_m = alpha*1e10
    sum_q2 = np.sum(charges_c**2)

    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2
    return self_energy


def compute_intra_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    unique_mols = np.unique(mol_ids)
    intra_energy = 0.0

    for m_id in unique_mols:
        idxs = np.where(mol_ids == m_id)[0]
        for i in range(len(idxs) - 1):
            for j in range(i + 1, len(idxs)):
                idx_i = idxs[i]
                idx_j = idxs[j]
                dx = positions[idx_j, 0] - positions[idx_i, 0]
                dy = positions[idx_j, 1] - positions[idx_i, 1]
                dz = positions[idx_j, 2] - positions[idx_i, 2]
                r = math.sqrt(dx**2 + dy**2 + dz**2)
                if r > 1e-14:
                    q_i = charges[idx_i]*e_charge
                    q_j = charges[idx_j]*e_charge
                    r_m = r*1e-10
                    erf_val = erf(alpha*r)
                    # negative sign for intramolecular
                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val
                    intra_energy -= val

    return intra_energy


# DataFrame Descriptions:

# 1. NIST_TRICLINIC_SPC_E_Water DataFrame:
#    - Contains thermodynamic properties of SPC/E water configurations in both triclinic and monoclinic cells.
#    - Columns:
#        - 'Configuration' (int): Configuration ID (1-4).
#        - 'M (number of SPC/E molecules)' (int): Number of SPC/E molecules in the system.
#        - 'Cell Type' (str): Type of the cell (e.g., Triclinic, Monoclinic).
#        - 'Cell Side Lengths [a, b, c] (Å)' (list of strings): Cell side lengths in Ångströms.
#        - 'Cell Angles [α, β, γ] (degrees)' (list of strings): Cell angles in degrees.
#        - 'Number of Wave Vectors' (int): The number of wave vectors for each configuration.
#        - 'Edisp/kB (K)' (float): Dispersion energy in Kelvin.
#        - 'ELRC/kB (K)' (float): Long-range correction energy in Kelvin.
#        - 'Ereal/kB (K)' (float): Real energy in Kelvin.
#        - 'Efourier/kB (K)' (float): Fourier transform energy in Kelvin.
#        - 'Eself/kB (K)' (float): Self-interaction energy in Kelvin.
#        - 'Eintra/kB (K)' (float): Intra-molecular energy in Kelvin.
#        - 'Etotal/kB (K)' (float): Total energy in Kelvin.

# 2. force_field DataFrame:
#    - Contains force field parameters for SPC/E water, specifically for oxygen ('O') and hydrogen ('H').
#    - Columns:
#        - 'type' (str): Atom type ('O' or 'H').
#        - 'sigma' (float): Lennard-Jones parameter (Å).
#        - 'epsilon' (float): Lennard-Jones well depth (K).
#        - 'charge' (float): Partial charge (e).
#        - 'num_particles' (int): Number of particles per molecule.

# 3. system DataFrame:
#    - Contains metadata about each system configuration.
#    - Columns:
#        - 'file_paths' (str): File names containing atomic configurations.
#        - 'configuration #' (int): Extracted configuration number (1-4).
#        - 'number of particles' (float): Number of molecules (from 'NIST_SPC_E_Water').
#        - 'box length' (float): Box dimensions (from 'NIST_SPC_E_Water').
#        - 'cutoff' (int): Fixed cutoff distance for interactions (10 Å).
#        - 'alpha' (float): Ewald summation parameter (5.6 / min(a, b, c)).
#        - 'kmax' (int): Maximum wave vector index (5); also, only include k for which k² < kmax² + 2, i.e., k² < 27.
#        - 'ε0' (float): Permittivity of Vacuum (8.854187817E-12 C²/(J m)).
#        - 'kB' (float): Boltzmann Constant (1.3806488E-23 J/K).

# 4. configuration DataFrame (from 'extracting_positions'):
#    - Created per file, containing atomic positions.
#    - Columns:
#        - 'X' (float): Atom coordinates in Ångströms.
#        - 'Y' (float): Atom coordinates in Ångströms.
#        - 'Z' (float): Atom coordinates in Ångströms.
#        - 'Atom Type' (str): Type of atom ('O' or 'H').
#        - 'Molecule' (int): Molecule index assigned based on position.


system, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties,NIST_TRICLINIC_SPC_E_Water)

# Computing energies storing in results
results = pd.DataFrame()

results['Number of Particles'] = system['number of particles'].astype(int)

# Calculate LRC energy for all system configurations
results['lrc_Energies'] = system.apply(
    lambda row: compute_lrc_energy(row, force_field), axis=1
)

# Calculate pairwise energy for all system configurations
results['dispersion_energies'] = system['file_paths'].apply(
    lambda file_path: pair_dispersion_energy(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path), 
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['real_energies'] = system['file_paths'].apply(
    lambda file_path: compute_real_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['fourier_energies'] = system['file_paths'].apply(
    lambda file_path: compute_fourier_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['self_energies'] = system['file_paths'].apply(
    lambda file_path: compute_self_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['intra_energies'] = system['file_paths'].apply(
    lambda file_path: compute_intra_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

def compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):
    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')

    matched_real = matched_fourier = matched_self = matched_intra = 0
    matched_dispersion = matched_lrc = 0
    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0
    not_matched_dispersion = not_matched_lrc = 0
    l2_dispersion = l2_lrc = l2_real = 0.0
    l2_fourier = l2_self = l2_intra = 0.0

    real_energy_output = []
    fourier_energy_output = []
    self_energy_output = []
    intra_energy_output = []
    lrc_energy_output = []
    dispersion_energy_output = []

    for idx, row in df_merged.iterrows():
        real_energy = row['real_energies']
        fourier_energy = row['fourier_energies']
        self_energy = row['self_energies']
        intra_energy = row['intra_energies']
        num_molecules = row['Number of Particles']
        lrc_energy = row['lrc_Energies']
        dispersion_energy = row['dispersion_energies']

        if pd.isna(row['Ereal/kB (K)']):
            continue
        nist_real_energy = float(row['Ereal/kB (K)'])
        nist_fourier_energy = float(row['Efourier/kB (K)'])
        nist_self_energy = float(row['Eself/kB (K)'])
        nist_intra_energy = float(row['Eintra/kB (K)'])
        nist_lrc_energy = float(row['ELRC/kB (K)'])
        nist_dispersion_energy = float(row['Edisp/kB (K)'])

        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)
        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)
        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)
        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)
        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)
        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)

        matched_real += int(match_real)
        not_matched_real += int(not match_real)
        matched_fourier += int(match_fourier)
        not_matched_fourier += int(not match_fourier)
        matched_self += int(match_self)
        not_matched_self += int(not match_self)
        matched_intra += int(match_intra)
        not_matched_intra += int(not match_intra)
        matched_dispersion += int(match_dispersion)
        not_matched_dispersion += int(not match_dispersion)
        matched_lrc += int(match_lrc)
        not_matched_lrc += int(not match_lrc)

        dispersion_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}"")
        lrc_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}"")
        real_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}"")
        fourier_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}"")
        self_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}"")
        intra_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}"")

        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)
        l2_lrc = np.square(lrc_energy - nist_lrc_energy)
        l2_real = np.square(real_energy - nist_real_energy)
        l2_fourier = np.square(fourier_energy - nist_fourier_energy)
        l2_self = np.square(self_energy - nist_self_energy)
        l2_intra = np.square(intra_energy - nist_intra_energy)

    print()
    print(""Lennard-Jones Pair Dispersion Energy Comparison:"")
    print(*dispersion_energy_output)
    print(""Lennard-Jones long-range corrections Energy Comparison:"")
    print(*lrc_energy_output)
    print(""Real Energy Comparison:"")
    print(*real_energy_output)
    print(""Fourier Energy Comparison:"")
    print(*fourier_energy_output)
    print(""Self Energy Comparison:"")
    print(*self_energy_output)
    print(""Intra Energy Comparison:"")
    print(*intra_energy_output)
    print()
    print(f""Count of correct pairwise answers: {matched_dispersion}"")
    print(f""Count of incorrect pairwise answers: {not_matched_dispersion}"")
    print(f""Count of correct LRC answers: {matched_lrc}"")
    print(f""Count of incorrect LRC answers: {not_matched_lrc}"")
    print(f""Count of correct Real Energy answers: {matched_real}"")
    print(f""Count of incorrect Real Energy answers: {not_matched_real}"")
    print(f""Count of correct Fourier Energy answers: {matched_fourier}"")
    print(f""Count of incorrect Fourier Energy answers: {not_matched_fourier}"")
    print(f""Count of correct Self Energy answers: {matched_self}"")
    print(f""Count of incorrect Self Energy answers: {not_matched_self}"")
    print(f""Count of correct Intra Energy answers: {matched_intra}"")
    print(f""Count of incorrect Intra Energy answers: {not_matched_intra}"")
    print()
    print(f""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}"")
    print(f""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}"")
    print(f""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}"")
    print(f""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}"")
    print(f""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}"")
    print(f""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}"")
    print(f""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}"")
    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc
    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc
    print(f""Total correct answers: {total_correct}"")
    print(f""Total incorrect answers: {total_incorrect}"")


# calling compare_coulomb_energy function
compare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)


Context:
Illustration of input file format:

            3.000000000000e+01       3.000000000000e+01       3.000000000000e+01
            8.500000000000e+01       7.500000000000e+01       8.000000000000e+01
         200
    1      -1.073606597760e+01       1.432194046140e+01      -6.226901963110e+00    O
    2      -1.661030970030e+01      -1.461065205480e+01      -5.798020258290e+00    H
    3      -1.118063417070e+01       1.380841402440e+01      -6.960829561930e+00    H
    4      -1.377161709910e+01      -8.711236583990e+00      -1.350200277380e+01    O
    5      -1.347193958490e+01      -8.247621904110e+00      -1.433582218840e+01    H
   
Formula for the potential energy for the SPC/E model of water(latex form):

\Large E_{total}\left( \mathbf{r}^N \right) = E_{disp}\left( \mathbf{r}^N \right) + E_{LRC} + E_{coulomb}\left( \mathbf{r}^N \right)

The terms on the right-hand side of the equality to be computed are:

1) The pair dispersion energy

2) The long-range correction to the pair dispersion energy

3) The Coulombic potential energy

Formula for the Coulombic potential energy(latex form):

\Large \begin{eqnarray} E_{coulomb}\left(\mathbf{r}^N\right) & = &
\sum\limits_{j}  \sum\limits_{l>j}
\dfrac{q_j q_l}{ 4 \pi \epsilon_0} \dfrac{\text{erfc}\left(\alpha \cdot  \left| \mathbf{r}_{jl} \right| \right)}{\left| \mathbf{r}_{jl} \right|} \Theta\left( r_{cut} - \left|\mathbf{r}_{jl}\right| \right) \\
&& +\dfrac{1}{2 \pi V} \sum\limits_{\mathbf{k} \neq \mathbf{0}} \dfrac{1}{k^2} \exp \left[-\left( \dfrac{\pi k}{\alpha} \right)^2 \right] \dfrac{1}{4 \pi \epsilon_0} \cdot \left|\sum\limits_{j=1}^N q_j \exp \left(2\pi i \mathbf{k} \cdot \mathbf{r}_j \right) \right|^2 \\
&& - \dfrac{\alpha}{\sqrt{\pi}} \sum\limits_j \dfrac{q_j^2}{4 \pi \epsilon_0} \\
&& - \sum\limits_{j=1}^M  \sum\limits_{\kappa}  \sum\limits_{\lambda>\kappa} \dfrac{q_{j_\kappa} q_{j_\lambda}}{ 4 \pi \epsilon_0} \dfrac{\text{erf}\left(\alpha \cdot  \left| \mathbf{r}_{j_\kappa j_\lambda} \right| \right)}{\left| \mathbf{r}_{j_\kappa j_\lambda} \right|}
\end{eqnarray}

The Coulombic energy is computed using the Ewald Summation Method. The terms on the right hand side of the equality are

1) The real-space term Ereal,

2) The Fourier-space term, Efourier,

3) The self-correction term Eself,

4) The intramolecular term Eintra.

Primary task:

Modify the functions in the code above, considering the input format.

Incorporate any additional functions that might be required.

Make the necessary changes to the dataframes to accommodate the updated input format.

You may access the required columns from the given dataframes as parameters to the function to calculate the energies.

You may modify other parts of the code, except the compare_LJ_coulomb_energy function.

Strict Requirements:

Do not modify the function names or parameters.

The output should always include Python code for modifying the respective functions.

The compare_LJ_coulomb_energy function should remain unchanged, as it controls the iteration loop.

Ensure that the print statements in the compare_LJ_coulomb_energy function remain exactly as they are, even as you make modifications to the other functions.

Iteration Notes: 

If multiple functions are provided to solve the task, work through them one by one in each iteration.

The iteration loop will continue until the desired outcome is achieved.

Output Format:

Produce a JSON output in the following format:
  ""Reasoning"": """",
  ""Code"": """"

Ensure that:
1. The JSON output is **properly formatted** with **double quotes** around keys.
2. The **Reasoning** section provides a concise and clear explanation of the approach taken.
3. The **Code** section contains well-structured, indented, and syntactically correct Python (or the required language).
4. The JSON output does **not** contain extraneous symbols such as triple backticks (` ``` `) or markdown indicators.
5. The output should be **fully valid JSON** and parseable using `json.loads()`.

Feedback Integration: 

When feedback is provided, ensure you proceed with the next steps based on the iteration results and the correct answers generated. Focus on the L2 score to reduce errors.


Result from the code generated:

            Your code resulted in the following error from 0 iterations. The threshold is 3. Resolve the error before the 3rd attempt:
            Error
            Traceback (most recent call last):
  File ""<string>"", line 567, in <module>
  File ""<string>"", line 114, in creating_dataframes
KeyError: 'a' 
            Review the specific part or function causing the error in the next iteration and correct it.
            ","{
  ""Reasoning"": ""The KeyError for 'a' arises because 'extracting_positions' never actually stored box parameters (a, b, c, α, β, γ, M) in configuration.attrs. To fix this, we parse the first three lines to extract (a, b, c), (α, β, γ), the number of molecules M, and store them as attributes before reading atomic coordinates from line 3 onward. This way, the subsequent calls to config_temp.attrs['a'] etc. will work as intended."",
  ""Code"": ""import numpy as np\nimport pandas as pd\nfrom scipy.special import erfc, erf\nimport math\n\n# defining all variables\natom_properties = {\n    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},\n    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},\n}\n\nfile_paths = [\n    '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'\n]\n\nNIST_TRICLINIC_SPC_E_Water = {\n    'Configuration': [1, 2, 3, 4],\n    'M (number of SPC/E molecules)': [400, 300, 200, 100],\n    'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],\n    'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]', '[27 Å, 30 Å, 36 Å]', '[30 Å, 30 Å, 30 Å]', '[36 Å, 36 Å, 36 Å]'],\n    'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]', '[90°, 75°, 90°]', '[85°, 75°, 80°]', '[90°, 60°, 90°]'],\n    'Number of Wave Vectors': [831, 1068, 838, 1028],\n    'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],\n    'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],\n    'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],\n    'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],\n    'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],\n    'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],\n    'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]\n}\n\n# 1) Updated extracting_positions function to parse the first three lines for box parameters\n\ndef extracting_positions(input_file):\n    with open(input_file, \""r\"") as file:\n        lines = file.readlines()\n\n    # Parse box dimensions and angles\n    line0 = lines[0].split()\n    a = float(line0[0])\n    b = float(line0[1])\n    c = float(line0[2])\n\n    line1 = lines[1].split()\n    alpha_deg = float(line1[0])\n    beta_deg = float(line1[1])\n    gamma_deg = float(line1[2])\n\n    # Parse number of molecules\n    line2 = lines[2].split()\n    M = int(line2[0])\n\n    # The rest are atomic coordinates\n    data_lines = lines[3:]\n\n    data_list = []\n    for line in data_lines:\n        stripped_line = line.strip()\n        parts = stripped_line.split()\n        if len(parts) >= 5:\n            try:\n                x, y, z = map(float, parts[1:4])\n                atom_type = parts[4]\n                data_list.append([x, y, z, atom_type])\n            except ValueError:\n                continue  \n\n    columns = [\""X\"", \""Y\"", \""Z\"", \""Atom Type\""]\n    configuration = pd.DataFrame(data_list, columns=columns)\n    configuration.index = range(1, len(configuration) + 1)\n\n    # Assign molecule ID\n    configuration[\""Molecule\""] = ((configuration.index - 1) // 3) + 1\n\n    # Store box info\n    configuration.attrs[\""a\""] = a\n    configuration.attrs[\""b\""] = b\n    configuration.attrs[\""c\""] = c\n    configuration.attrs[\""alpha_deg\""] = alpha_deg\n    configuration.attrs[\""beta_deg\""] = beta_deg\n    configuration.attrs[\""gamma_deg\""] = gamma_deg\n    configuration.attrs[\""M\""] = M\n\n    return configuration\n\n# We no longer need parse_cell_sides or parse_cell_angles, but we'll leave them if needed.\ndef parse_cell_sides(sides_str):\n    sides_str = sides_str.strip().strip('[]')\n    parts = sides_str.split(',')\n    values = []\n    for p in parts:\n        p = p.strip()\n        p = p.replace('Å', '')\n        values.append(float(p))\n    return values\n\ndef parse_cell_angles(angles_str):\n    angles_str = angles_str.strip().strip('[]')\n    parts = angles_str.split(',')\n    values = []\n    for p in parts:\n        p = p.strip()\n        p = p.replace('°', '')\n        values.append(float(p))\n    return values\n\n# 2) creating_dataframes function picks up the box data from configuration.attrs\n\ndef creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):\n    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)\n    NIST_SPC_E_Water['Sum of energies'] = (\n        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +\n        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +\n        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']\n    )\n\n    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')\n\n    system_rows = []\n    for file_path in file_paths:\n        config_temp = extracting_positions(file_path)\n        a = config_temp.attrs[\""a\""]\n        b = config_temp.attrs[\""b\""]\n        c = config_temp.attrs[\""c\""]\n        alpha_deg = config_temp.attrs[\""alpha_deg\""]\n        beta_deg = config_temp.attrs[\""beta_deg\""]\n        gamma_deg = config_temp.attrs[\""gamma_deg\""]\n        M = config_temp.attrs[\""M\""]\n\n        import re\n        match_conf = re.search(r'(\\d+)', file_path)\n        conf_num = int(match_conf.group(1)) if match_conf else 0\n\n        system_dict = {\n            \""file_paths\"": file_path,\n            \""configuration #\"": conf_num,\n            \""number of particles\"": float(M),\n            \""a\"": a,\n            \""b\"": b,\n            \""c\"": c,\n            \""alpha_deg\"": alpha_deg,\n            \""beta_deg\"": beta_deg,\n            \""gamma_deg\"": gamma_deg\n        }\n        system_rows.append(system_dict)\n\n    system = pd.DataFrame(system_rows)\n\n    # Choose a 10A cutoff\n    system['cutoff'] = 10.0\n\n    def alpha_value(row):\n        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28\n\n    system['alpha'] = system.apply(alpha_value, axis=1)\n    system['kmax'] = 5\n    system['ε0'] = float(8.854187817E-12)\n    system['kB'] = float(1.3806488E-23)\n\n    return system, force_field, NIST_SPC_E_Water\n\n# Minimum image helper for cubic (no longer used, but left for reference)\ndef minimum_image_distance(r_ij, cell_length):\n    return r_ij - cell_length * np.round(r_ij / cell_length)\n\n# Build triclinic matrix and min image for triclinic\n\ndef build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):\n    alpha = math.radians(alpha_deg)\n    beta = math.radians(beta_deg)\n    gamma = math.radians(gamma_deg)\n\n    ax = a\n    ay = 0.0\n    az = 0.0\n\n    bx = b * math.cos(gamma)\n    by = b * math.sin(gamma)\n    bz = 0.0\n\n    sin_gamma = math.sin(gamma)\n    cx = c * math.cos(beta)\n    if abs(sin_gamma) < 1e-14:\n        sin_gamma = 1e-14\n    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)\n    cz = math.sqrt(c**2 - cx**2 - cy**2)\n\n    h = np.array([\n        [ax, bx, cx],\n        [ay, by, cy],\n        [az, bz, cz]\n    ], dtype=float)\n\n    h_inv = np.linalg.inv(h)\n    return h, h_inv\n\ndef min_image_distance_triclinic(r_ij, h, h_inv):\n    frac = h_inv.dot(r_ij)\n    frac -= np.round(frac)\n    return h.dot(frac)\n\n# Pairwise dispersion\n\ndef pair_dispersion_energy(system_data, configuration, force_field):\n    positions = configuration[['X', 'Y', 'Z']].values\n    atom_types = configuration['Atom Type'].values\n    cutoff = system_data['cutoff']\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n\n    total_dispersion_energy = 0.0\n    num_atoms = len(positions)\n\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            r_ij = positions[i] - positions[j]\n            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)\n            distance = np.linalg.norm(r_ij)\n\n            if 0 < distance < cutoff:\n                type_i = atom_types[i]\n                type_j = atom_types[j]\n                if type_i not in force_field.index or type_j not in force_field.index:\n                    continue\n\n                epsilon_i = force_field.loc[type_i, 'epsilon']\n                epsilon_j = force_field.loc[type_j, 'epsilon']\n                sigma_i = force_field.loc[type_i, 'sigma']\n                sigma_j = force_field.loc[type_j, 'sigma']\n\n                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)\n                sigma_ij = 0.5 * (sigma_i + sigma_j)\n                s_over_r = sigma_ij / distance\n                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)\n                total_dispersion_energy += lj_pot\n\n    return total_dispersion_energy\n\n# LRC\n\ndef compute_lrc_energy(system_row, force_field):\n    U_lrc_total = 0.0\n    cutoff = system_row['cutoff']\n\n    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],\n                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])\n    volume = abs(np.linalg.det(h))\n\n    for atom_type, atom_data in force_field.iterrows():\n        num_particles = system_row['number of particles'] * atom_data['num_particles']\n        rho = num_particles / volume\n        sigma = atom_data['sigma']\n        epsilon = atom_data['epsilon']\n\n        if cutoff > 0:\n            sc3 = (sigma / cutoff)**3\n            sc9 = sc3**3\n        else:\n            sc3, sc9 = 0.0, 0.0\n\n        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)\n        U_lrc *= num_particles\n        U_lrc_total += U_lrc\n\n    return U_lrc_total\n\n# Real-space term\n\ndef compute_real_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data[\""alpha\""]\n    cutoff = system_data[\""cutoff\""]\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n\n    positions = configuration[[\""X\"", \""Y\"", \""Z\""]].values\n    atom_types = configuration[\""Atom Type\""].values\n    mol_ids = configuration[\""Molecule\""].values\n    charges = np.array([force_field.loc[t, \""charge\""] for t in atom_types])\n\n    real_energy = 0.0\n    n_atoms = len(positions)\n\n    for j in range(n_atoms - 1):\n        for l in range(j + 1, n_atoms):\n            if mol_ids[j] == mol_ids[l]:\n                continue\n            r_ij = positions[l] - positions[j]\n            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)\n            distance = np.linalg.norm(r_ij)\n            if 1e-14 < distance < cutoff:\n                q_j = charges[j]*e_charge\n                q_l = charges[l]*e_charge\n                r_m = distance*1e-10\n                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)\n\n    return real_energy\n\n# Fourier term\n\ndef compute_fourier_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data[\""alpha\""]\n    kmax = system_data[\""kmax\""]\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n    V_m = abs(np.linalg.det(h))*(1e-10**3)\n\n    positions = configuration[[\""X\"", \""Y\"", \""Z\""]].values\n    atom_types = configuration[\""Atom Type\""].values\n    charges = np.array([force_field.loc[t, \""charge\""] for t in atom_types])\n    charges_c = charges*e_charge\n\n    positions_m = positions*1e-10\n    prefactor = coulomb_factor/(2.0*V_m)\n\n    alpha_m = alpha*1e10\n    fourier_energy = 0.0\n\n    max_sq = kmax*kmax + 2\n    L_avg = (a + b + c)/3.0\n    kfactor = 2.0*math.pi/(L_avg*1e-10)\n\n    for kx in range(-kmax, kmax+1):\n        for ky in range(-kmax, kmax+1):\n            for kz in range(-kmax, kmax+1):\n                if (kx == 0 and ky == 0 and kz == 0):\n                    continue\n                if (kx*kx + ky*ky + kz*kz) >= max_sq:\n                    continue\n\n                kx_m = kfactor*kx\n                ky_m = kfactor*ky\n                kz_m = kfactor*kz\n                k_sq = kx_m**2 + ky_m**2 + kz_m**2\n                if k_sq < 1e-14:\n                    continue\n\n                real_part = 0.0\n                imag_part = 0.0\n                for j, (xj, yj, zj) in enumerate(positions_m):\n                    kr = kx_m*xj + ky_m*yj + kz_m*zj\n                    real_part += charges_c[j]*math.cos(kr)\n                    imag_part += charges_c[j]*math.sin(kr)\n\n                sk_sq = real_part**2 + imag_part**2\n                exp_factor = math.exp(-k_sq/(4.0*alpha_m**2))\n\n                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq\n                fourier_energy += term\n\n    return fourier_energy\n\n# Self term\n\ndef compute_self_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n    atom_types = configuration['Atom Type'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n    charges_c = charges*e_charge\n\n    alpha_m = alpha*1e10\n    sum_q2 = np.sum(charges_c**2)\n\n    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2\n    return self_energy\n\n# Intra term\n\ndef compute_intra_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n\n    positions = configuration[[\""X\"", \""Y\"", \""Z\""]].values\n    atom_types = configuration['Atom Type'].values\n    mol_ids = configuration['Molecule'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n\n    unique_mols = np.unique(mol_ids)\n    intra_energy = 0.0\n\n    for m_id in unique_mols:\n        idxs = np.where(mol_ids == m_id)[0]\n        for i in range(len(idxs) - 1):\n            for j in range(i + 1, len(idxs)):\n                idx_i = idxs[i]\n                idx_j = idxs[j]\n                dx = positions[idx_j, 0] - positions[idx_i, 0]\n                dy = positions[idx_j, 1] - positions[idx_i, 1]\n                dz = positions[idx_j, 2] - positions[idx_i, 2]\n                r = math.sqrt(dx**2 + dy**2 + dz**2)\n                if r > 1e-14:\n                    q_i = charges[idx_i]*e_charge\n                    q_j = charges[idx_j]*e_charge\n                    r_m = r*1e-10\n                    erf_val = erf(alpha*r)\n                    # negative sign for intramolecular\n                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val\n                    intra_energy -= val\n\n    return intra_energy\n\nsystem, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties, NIST_TRICLINIC_SPC_E_Water)\n\nresults = pd.DataFrame()\n\nresults['Number of Particles'] = system['number of particles'].astype(int)\n\nresults['lrc_Energies'] = system.apply(\n    lambda row: compute_lrc_energy(row, force_field), axis=1\n)\n\nresults['dispersion_energies'] = system['file_paths'].apply(\n    lambda file_path: pair_dispersion_energy(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['real_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_real_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['fourier_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_fourier_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['self_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_self_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['intra_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_intra_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\ndef compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):\n    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')\n\n    matched_real = matched_fourier = matched_self = matched_intra = 0\n    matched_dispersion = matched_lrc = 0\n    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0\n    not_matched_dispersion = not_matched_lrc = 0\n    l2_dispersion = l2_lrc = l2_real = 0.0\n    l2_fourier = l2_self = l2_intra = 0.0\n\n    real_energy_output = []\n    fourier_energy_output = []\n    self_energy_output = []\n    intra_energy_output = []\n    lrc_energy_output = []\n    dispersion_energy_output = []\n\n    for idx, row in df_merged.iterrows():\n        real_energy = row['real_energies']\n        fourier_energy = row['fourier_energies']\n        self_energy = row['self_energies']\n        intra_energy = row['intra_energies']\n        num_molecules = row['Number of Particles']\n        lrc_energy = row['lrc_Energies']\n        dispersion_energy = row['dispersion_energies']\n\n        if pd.isna(row['Ereal/kB (K)']):\n            continue\n        nist_real_energy = float(row['Ereal/kB (K)'])\n        nist_fourier_energy = float(row['Efourier/kB (K)'])\n        nist_self_energy = float(row['Eself/kB (K)'])\n        nist_intra_energy = float(row['Eintra/kB (K)'])\n        nist_lrc_energy = float(row['ELRC/kB (K)'])\n        nist_dispersion_energy = float(row['Edisp/kB (K)'])\n\n        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)\n        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)\n        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)\n        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)\n        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)\n        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)\n\n        matched_real += int(match_real)\n        not_matched_real += int(not match_real)\n        matched_fourier += int(match_fourier)\n        not_matched_fourier += int(not match_fourier)\n        matched_self += int(match_self)\n        not_matched_self += int(not match_self)\n        matched_intra += int(match_intra)\n        not_matched_intra += int(not match_intra)\n        matched_dispersion += int(match_dispersion)\n        not_matched_dispersion += int(not match_dispersion)\n        matched_lrc += int(match_lrc)\n        not_matched_lrc += int(not match_lrc)\n\n        dispersion_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}\"")\n        lrc_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}\"")\n        real_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}\"")\n        fourier_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}\"")\n        self_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}\"")\n        intra_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}\"")\n\n        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)\n        l2_lrc = np.square(lrc_energy - nist_lrc_energy)\n        l2_real = np.square(real_energy - nist_real_energy)\n        l2_fourier = np.square(fourier_energy - nist_fourier_energy)\n        l2_self = np.square(self_energy - nist_self_energy)\n        l2_intra = np.square(intra_energy - nist_intra_energy)\n\n    print()\n    print(\""Lennard-Jones Pair Dispersion Energy Comparison:\"")\n    print(*dispersion_energy_output)\n    print(\""Lennard-Jones long-range corrections Energy Comparison:\"")\n    print(*lrc_energy_output)\n    print(\""Real Energy Comparison:\"")\n    print(*real_energy_output)\n    print(\""Fourier Energy Comparison:\"")\n    print(*fourier_energy_output)\n    print(\""Self Energy Comparison:\"")\n    print(*self_energy_output)\n    print(\""Intra Energy Comparison:\"")\n    print(*intra_energy_output)\n    print()\n    print(f\""Count of correct pairwise answers: {matched_dispersion}\"")\n    print(f\""Count of incorrect pairwise answers: {not_matched_dispersion}\"")\n    print(f\""Count of correct LRC answers: {matched_lrc}\"")\n    print(f\""Count of incorrect LRC answers: {not_matched_lrc}\"")\n    print(f\""Count of correct Real Energy answers: {matched_real}\"")\n    print(f\""Count of incorrect Real Energy answers: {not_matched_real}\"")\n    print(f\""Count of correct Fourier Energy answers: {matched_fourier}\"")\n    print(f\""Count of incorrect Fourier Energy answers: {not_matched_fourier}\"")\n    print(f\""Count of correct Self Energy answers: {matched_self}\"")\n    print(f\""Count of incorrect Self Energy answers: {not_matched_self}\"")\n    print(f\""Count of correct Intra Energy answers: {matched_intra}\"")\n    print(f\""Count of incorrect Intra Energy answers: {not_matched_intra}\"")\n    print()\n    print(f\""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}\"")\n    print(f\""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}\"")\n    print(f\""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}\"")\n    print(f\""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}\"")\n    print(f\""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}\"")\n    print(f\""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}\"")\n    print(f\""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}\"")\n    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc\n    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc\n    print(f\""Total correct answers: {total_correct}\"")\n    print(f\""Total incorrect answers: {total_incorrect}\"")\n\n# calling compare function\ncompare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)\n""
}","import numpy as np
import pandas as pd
from scipy.special import erfc,erf
import math 

# defining all variables
atom_properties = {
    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},
    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},
}

# Trying for small configurations first
file_paths = [
    #    '../data/spce_sample_config_periodic4.txt',
    #    '../data/spce_sample_config_periodic2.txt',
    #    '../data/spce_sample_config_periodic3.txt',
        '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'
    ]

NIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],
 'M (number of SPC/E molecules)': [400, 300, 200, 100],
 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],
 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',
  '[27 Å, 30 Å, 36 Å]',
  '[30 Å, 30 Å, 30 Å]',
  '[36 Å, 36 Å, 36 Å]'],
 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',
  '[90°, 75°, 90°]',
  '[85°, 75°, 80°]',
  '[90°, 60°, 90°]'],
 'Number of Wave Vectors': [831, 1068, 838, 1028],
 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],
 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],
 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],
 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],
 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],
 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],
 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}

# Data processing






def extracting_positions(input_file):
        # Extract the positions from the .xyz file
    with open(input_file, ""r"") as file:
        lines = file.readlines()

    data_lines = lines[2:]

    data_list = []
    for line in data_lines:
        stripped_line = line.strip()
        parts = stripped_line.split()
        if len(parts) >= 5:  
            try:
                x, y, z = map(float, parts[1:4])
                atom_type = parts[4]
                data_list.append([x, y, z, atom_type])
            except ValueError:
                continue  

    # Create a DataFrame with all configurations
    columns = [""X"", ""Y"", ""Z"", ""Atom Type""]
    configuration = pd.DataFrame(data_list, columns=columns)

    configuration.index = range(1, len(configuration) + 1)

    configuration[""Molecule""] = ((configuration.index - 1) // 3) + 1
    
    return configuration

# create the target dataframes
def parse_cell_sides(sides_str):
    sides_str = sides_str.strip().strip('[]')
    parts = sides_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('Å', '')
        values.append(float(p))
    return values

def parse_cell_angles(angles_str):
    angles_str = angles_str.strip().strip('[]')
    parts = angles_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('°', '')
        values.append(float(p))
    return values

def creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):
    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)
    NIST_SPC_E_Water['Sum of energies'] = (
        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +
        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +
        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']
    )

    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')

    system_rows = []
    for file_path in file_paths:
        config_temp = extracting_positions(file_path)
        a = config_temp.attrs[""a""]
        b = config_temp.attrs[""b""]
        c = config_temp.attrs[""c""]
        alpha_deg = config_temp.attrs[""alpha_deg""]
        beta_deg = config_temp.attrs[""beta_deg""]
        gamma_deg = config_temp.attrs[""gamma_deg""]
        M = config_temp.attrs[""M""]

        import re
        match_conf = re.search(r'(\d+)', file_path)
        conf_num = int(match_conf.group(1)) if match_conf else 0

        system_dict = {
            ""file_paths"": file_path,
            ""configuration #"": conf_num,
            ""number of particles"": float(M),
            ""a"": a,
            ""b"": b,
            ""c"": c,
            ""alpha_deg"": alpha_deg,
            ""beta_deg"": beta_deg,
            ""gamma_deg"": gamma_deg
        }
        system_rows.append(system_dict)

    system = pd.DataFrame(system_rows)

    # Choose a 10A cutoff
    system['cutoff'] = 10.0

    def alpha_value(row):
        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28

    system['alpha'] = system.apply(alpha_value, axis=1)
    system['kmax'] = 5
    system['ε0'] = float(8.854187817E-12)
    system['kB'] = float(1.3806488E-23)

    return system, force_field, NIST_SPC_E_Water

# pairwise dispersion energy functions

# Minimum Image Distance function and Pair Dispersion Energy calculation (Code 3)
def minimum_image_distance(r_ij, cell_length):
    return r_ij - cell_length * np.round(r_ij / cell_length)

# pairwise dispersion energy operation
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def pair_dispersion_energy(system_data, configuration, force_field):
    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    total_dispersion_energy = 0.0
    num_atoms = len(positions)

    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            r_ij = positions[i] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)

            if 0 < distance < cutoff:
                type_i = atom_types[i]
                type_j = atom_types[j]
                if type_i not in force_field.index or type_j not in force_field.index:
                    continue

                epsilon_i = force_field.loc[type_i, 'epsilon']
                epsilon_j = force_field.loc[type_j, 'epsilon']
                sigma_i = force_field.loc[type_i, 'sigma']
                sigma_j = force_field.loc[type_j, 'sigma']

                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)
                sigma_ij = 0.5 * (sigma_i + sigma_j)
                s_over_r = sigma_ij / distance
                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)
                total_dispersion_energy += lj_pot

    return total_dispersion_energy

# Compute LRC energy
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_lrc_energy(system_row, force_field):
    U_lrc_total = 0.0
    cutoff = system_row['cutoff']

    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],
                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])
    volume = abs(np.linalg.det(h))

    for atom_type, atom_data in force_field.iterrows():
        num_particles = system_row['number of particles'] * atom_data['num_particles']
        rho = num_particles / volume
        sigma = atom_data['sigma']
        epsilon = atom_data['epsilon']

        if cutoff > 0:
            sc3 = (sigma / cutoff)**3
            sc9 = sc3**3
        else:
            sc3, sc9 = 0.0, 0.0

        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)
        U_lrc *= num_particles
        U_lrc_total += U_lrc

    return U_lrc_total

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def compute_real_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    cutoff = system_data[""cutoff""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    mol_ids = configuration[""Molecule""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])

    real_energy = 0.0
    n_atoms = len(positions)

    for j in range(n_atoms - 1):
        for l in range(j + 1, n_atoms):
            if mol_ids[j] == mol_ids[l]:
                continue
            r_ij = positions[l] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)
            if 1e-14 < distance < cutoff:
                q_j = charges[j]*e_charge
                q_l = charges[l]*e_charge
                r_m = distance*1e-10
                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)

    return real_energy

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_fourier_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    kmax = system_data[""kmax""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)
    V_m = abs(np.linalg.det(h))*(1e-10**3)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])
    charges_c = charges*e_charge

    positions_m = positions*1e-10
    prefactor = coulomb_factor/(2.0*V_m)

    alpha_m = alpha*1e10
    fourier_energy = 0.0

    max_sq = kmax*kmax + 2
    L_avg = (a + b + c)/3.0
    kfactor = 2.0*math.pi/(L_avg*1e-10)

    for kx in range(-kmax, kmax+1):
        for ky in range(-kmax, kmax+1):
            for kz in range(-kmax, kmax+1):
                if (kx == 0 and ky == 0 and kz == 0):
                    continue
                if (kx*kx + ky*ky + kz*kz) >= max_sq:
                    continue

                kx_m = kfactor*kx
                ky_m = kfactor*ky
                kz_m = kfactor*kz
                k_sq = kx_m**2 + ky_m**2 + kz_m**2
                if k_sq < 1e-14:
                    continue

                real_part = 0.0
                imag_part = 0.0
                for j, (xj, yj, zj) in enumerate(positions_m):
                    kr = kx_m*xj + ky_m*yj + kz_m*zj
                    real_part += charges_c[j]*math.cos(kr)
                    imag_part += charges_c[j]*math.sin(kr)

                sk_sq = real_part**2 + imag_part**2
                exp_factor = math.exp(-k_sq/(4.0*alpha_m**2))

                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq
                fourier_energy += term

    return fourier_energy


def compute_self_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    alpha_m = alpha*1e10
    sum_q2 = np.sum(charges_c**2)

    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2
    return self_energy


def compute_intra_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    unique_mols = np.unique(mol_ids)
    intra_energy = 0.0

    for m_id in unique_mols:
        idxs = np.where(mol_ids == m_id)[0]
        for i in range(len(idxs) - 1):
            for j in range(i + 1, len(idxs)):
                idx_i = idxs[i]
                idx_j = idxs[j]
                dx = positions[idx_j, 0] - positions[idx_i, 0]
                dy = positions[idx_j, 1] - positions[idx_i, 1]
                dz = positions[idx_j, 2] - positions[idx_i, 2]
                r = math.sqrt(dx**2 + dy**2 + dz**2)
                if r > 1e-14:
                    q_i = charges[idx_i]*e_charge
                    q_j = charges[idx_j]*e_charge
                    r_m = r*1e-10
                    erf_val = erf(alpha*r)
                    # negative sign for intramolecular
                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val
                    intra_energy -= val

    return intra_energy


# DataFrame Descriptions:

# 1. NIST_TRICLINIC_SPC_E_Water DataFrame:
#    - Contains thermodynamic properties of SPC/E water configurations in both triclinic and monoclinic cells.
#    - Columns:
#        - 'Configuration' (int): Configuration ID (1-4).
#        - 'M (number of SPC/E molecules)' (int): Number of SPC/E molecules in the system.
#        - 'Cell Type' (str): Type of the cell (e.g., Triclinic, Monoclinic).
#        - 'Cell Side Lengths [a, b, c] (Å)' (list of strings): Cell side lengths in Ångströms.
#        - 'Cell Angles [α, β, γ] (degrees)' (list of strings): Cell angles in degrees.
#        - 'Number of Wave Vectors' (int): The number of wave vectors for each configuration.
#        - 'Edisp/kB (K)' (float): Dispersion energy in Kelvin.
#        - 'ELRC/kB (K)' (float): Long-range correction energy in Kelvin.
#        - 'Ereal/kB (K)' (float): Real energy in Kelvin.
#        - 'Efourier/kB (K)' (float): Fourier transform energy in Kelvin.
#        - 'Eself/kB (K)' (float): Self-interaction energy in Kelvin.
#        - 'Eintra/kB (K)' (float): Intra-molecular energy in Kelvin.
#        - 'Etotal/kB (K)' (float): Total energy in Kelvin.

# 2. force_field DataFrame:
#    - Contains force field parameters for SPC/E water, specifically for oxygen ('O') and hydrogen ('H').
#    - Columns:
#        - 'type' (str): Atom type ('O' or 'H').
#        - 'sigma' (float): Lennard-Jones parameter (Å).
#        - 'epsilon' (float): Lennard-Jones well depth (K).
#        - 'charge' (float): Partial charge (e).
#        - 'num_particles' (int): Number of particles per molecule.

# 3. system DataFrame:
#    - Contains metadata about each system configuration.
#    - Columns:
#        - 'file_paths' (str): File names containing atomic configurations.
#        - 'configuration #' (int): Extracted configuration number (1-4).
#        - 'number of particles' (float): Number of molecules (from 'NIST_SPC_E_Water').
#        - 'box length' (float): Box dimensions (from 'NIST_SPC_E_Water').
#        - 'cutoff' (int): Fixed cutoff distance for interactions (10 Å).
#        - 'alpha' (float): Ewald summation parameter (5.6 / min(a, b, c)).
#        - 'kmax' (int): Maximum wave vector index (5); also, only include k for which k² < kmax² + 2, i.e., k² < 27.
#        - 'ε0' (float): Permittivity of Vacuum (8.854187817E-12 C²/(J m)).
#        - 'kB' (float): Boltzmann Constant (1.3806488E-23 J/K).

# 4. configuration DataFrame (from 'extracting_positions'):
#    - Created per file, containing atomic positions.
#    - Columns:
#        - 'X' (float): Atom coordinates in Ångströms.
#        - 'Y' (float): Atom coordinates in Ångströms.
#        - 'Z' (float): Atom coordinates in Ångströms.
#        - 'Atom Type' (str): Type of atom ('O' or 'H').
#        - 'Molecule' (int): Molecule index assigned based on position.


system, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties,NIST_TRICLINIC_SPC_E_Water)

# Computing energies storing in results
results = pd.DataFrame()

results['Number of Particles'] = system['number of particles'].astype(int)

# Calculate LRC energy for all system configurations
results['lrc_Energies'] = system.apply(
    lambda row: compute_lrc_energy(row, force_field), axis=1
)

# Calculate pairwise energy for all system configurations
results['dispersion_energies'] = system['file_paths'].apply(
    lambda file_path: pair_dispersion_energy(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path), 
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['real_energies'] = system['file_paths'].apply(
    lambda file_path: compute_real_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['fourier_energies'] = system['file_paths'].apply(
    lambda file_path: compute_fourier_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['self_energies'] = system['file_paths'].apply(
    lambda file_path: compute_self_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['intra_energies'] = system['file_paths'].apply(
    lambda file_path: compute_intra_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

def compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):
    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')

    matched_real = matched_fourier = matched_self = matched_intra = 0
    matched_dispersion = matched_lrc = 0
    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0
    not_matched_dispersion = not_matched_lrc = 0
    l2_dispersion = l2_lrc = l2_real = 0.0
    l2_fourier = l2_self = l2_intra = 0.0

    real_energy_output = []
    fourier_energy_output = []
    self_energy_output = []
    intra_energy_output = []
    lrc_energy_output = []
    dispersion_energy_output = []

    for idx, row in df_merged.iterrows():
        real_energy = row['real_energies']
        fourier_energy = row['fourier_energies']
        self_energy = row['self_energies']
        intra_energy = row['intra_energies']
        num_molecules = row['Number of Particles']
        lrc_energy = row['lrc_Energies']
        dispersion_energy = row['dispersion_energies']

        if pd.isna(row['Ereal/kB (K)']):
            continue
        nist_real_energy = float(row['Ereal/kB (K)'])
        nist_fourier_energy = float(row['Efourier/kB (K)'])
        nist_self_energy = float(row['Eself/kB (K)'])
        nist_intra_energy = float(row['Eintra/kB (K)'])
        nist_lrc_energy = float(row['ELRC/kB (K)'])
        nist_dispersion_energy = float(row['Edisp/kB (K)'])

        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)
        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)
        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)
        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)
        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)
        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)

        matched_real += int(match_real)
        not_matched_real += int(not match_real)
        matched_fourier += int(match_fourier)
        not_matched_fourier += int(not match_fourier)
        matched_self += int(match_self)
        not_matched_self += int(not match_self)
        matched_intra += int(match_intra)
        not_matched_intra += int(not match_intra)
        matched_dispersion += int(match_dispersion)
        not_matched_dispersion += int(not match_dispersion)
        matched_lrc += int(match_lrc)
        not_matched_lrc += int(not match_lrc)

        dispersion_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}"")
        lrc_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}"")
        real_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}"")
        fourier_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}"")
        self_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}"")
        intra_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}"")

        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)
        l2_lrc = np.square(lrc_energy - nist_lrc_energy)
        l2_real = np.square(real_energy - nist_real_energy)
        l2_fourier = np.square(fourier_energy - nist_fourier_energy)
        l2_self = np.square(self_energy - nist_self_energy)
        l2_intra = np.square(intra_energy - nist_intra_energy)

    print()
    print(""Lennard-Jones Pair Dispersion Energy Comparison:"")
    print(*dispersion_energy_output)
    print(""Lennard-Jones long-range corrections Energy Comparison:"")
    print(*lrc_energy_output)
    print(""Real Energy Comparison:"")
    print(*real_energy_output)
    print(""Fourier Energy Comparison:"")
    print(*fourier_energy_output)
    print(""Self Energy Comparison:"")
    print(*self_energy_output)
    print(""Intra Energy Comparison:"")
    print(*intra_energy_output)
    print()
    print(f""Count of correct pairwise answers: {matched_dispersion}"")
    print(f""Count of incorrect pairwise answers: {not_matched_dispersion}"")
    print(f""Count of correct LRC answers: {matched_lrc}"")
    print(f""Count of incorrect LRC answers: {not_matched_lrc}"")
    print(f""Count of correct Real Energy answers: {matched_real}"")
    print(f""Count of incorrect Real Energy answers: {not_matched_real}"")
    print(f""Count of correct Fourier Energy answers: {matched_fourier}"")
    print(f""Count of incorrect Fourier Energy answers: {not_matched_fourier}"")
    print(f""Count of correct Self Energy answers: {matched_self}"")
    print(f""Count of incorrect Self Energy answers: {not_matched_self}"")
    print(f""Count of correct Intra Energy answers: {matched_intra}"")
    print(f""Count of incorrect Intra Energy answers: {not_matched_intra}"")
    print()
    print(f""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}"")
    print(f""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}"")
    print(f""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}"")
    print(f""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}"")
    print(f""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}"")
    print(f""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}"")
    print(f""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}"")
    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc
    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc
    print(f""Total correct answers: {total_correct}"")
    print(f""Total incorrect answers: {total_incorrect}"")


# calling compare_coulomb_energy function
compare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)"
1,3,2025-04-03_11:28:07,o1,medium,short,"Result from the code generated:

            Your code resulted in the following error from 0 iterations. The threshold is 3. Resolve the error before the 3rd attempt:
            Error
            Traceback (most recent call last):
  File ""<string>"", line 557, in <module>
  File ""<string>"", line 109, in creating_dataframes
KeyError: 'a' 
            Review the specific part or function causing the error in the next iteration and correct it.
            ","Please find the code generated in iteration 3. You have 0 iterations remaining to complete the code for triclinic box configurations by changing the cubic box configurations.


import numpy as np
import pandas as pd
from scipy.special import erfc,erf
import math 

# defining all variables
atom_properties = {
    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},
    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},
}

# Trying for small configurations first
file_paths = [
    #    '../data/spce_sample_config_periodic4.txt',
    #    '../data/spce_sample_config_periodic2.txt',
    #    '../data/spce_sample_config_periodic3.txt',
        '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'
    ]

NIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],
 'M (number of SPC/E molecules)': [400, 300, 200, 100],
 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],
 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',
  '[27 Å, 30 Å, 36 Å]',
  '[30 Å, 30 Å, 30 Å]',
  '[36 Å, 36 Å, 36 Å]'],
 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',
  '[90°, 75°, 90°]',
  '[85°, 75°, 80°]',
  '[90°, 60°, 90°]'],
 'Number of Wave Vectors': [831, 1068, 838, 1028],
 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],
 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],
 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],
 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],
 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],
 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],
 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}

# Data processing






def extracting_positions(input_file):
        # Extract the positions from the .xyz file
    with open(input_file, ""r"") as file:
        lines = file.readlines()

    data_lines = lines[2:]

    data_list = []
    for line in data_lines:
        stripped_line = line.strip()
        parts = stripped_line.split()
        if len(parts) >= 5:  
            try:
                x, y, z = map(float, parts[1:4])
                atom_type = parts[4]
                data_list.append([x, y, z, atom_type])
            except ValueError:
                continue  

    # Create a DataFrame with all configurations
    columns = [""X"", ""Y"", ""Z"", ""Atom Type""]
    configuration = pd.DataFrame(data_list, columns=columns)

    configuration.index = range(1, len(configuration) + 1)

    configuration[""Molecule""] = ((configuration.index - 1) // 3) + 1
    
    return configuration

# create the target dataframes
def parse_cell_sides(sides_str):
    sides_str = sides_str.strip().strip('[]')
    parts = sides_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('Å', '')
        values.append(float(p))
    return values

def parse_cell_angles(angles_str):
    angles_str = angles_str.strip().strip('[]')
    parts = angles_str.split(',')
    values = []
    for p in parts:
        p = p.strip()
        p = p.replace('°', '')
        values.append(float(p))
    return values

def creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):
    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)
    NIST_SPC_E_Water['Sum of energies'] = (
        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +
        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +
        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']
    )

    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')

    system_rows = []
    for file_path in file_paths:
        config_temp = extracting_positions(file_path)
        a = config_temp.attrs[""a""]
        b = config_temp.attrs[""b""]
        c = config_temp.attrs[""c""]
        alpha_deg = config_temp.attrs[""alpha_deg""]
        beta_deg = config_temp.attrs[""beta_deg""]
        gamma_deg = config_temp.attrs[""gamma_deg""]
        M = config_temp.attrs[""M""]

        import re
        match_conf = re.search(r'(\d+)', file_path)
        conf_num = int(match_conf.group(1)) if match_conf else 0

        system_dict = {
            ""file_paths"": file_path,
            ""configuration #"": conf_num,
            ""number of particles"": float(M),
            ""a"": a,
            ""b"": b,
            ""c"": c,
            ""alpha_deg"": alpha_deg,
            ""beta_deg"": beta_deg,
            ""gamma_deg"": gamma_deg
        }
        system_rows.append(system_dict)

    system = pd.DataFrame(system_rows)

    # Choose a 10A cutoff
    system['cutoff'] = 10.0

    def alpha_value(row):
        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28

    system['alpha'] = system.apply(alpha_value, axis=1)
    system['kmax'] = 5
    system['ε0'] = float(8.854187817E-12)
    system['kB'] = float(1.3806488E-23)

    return system, force_field, NIST_SPC_E_Water

# pairwise dispersion energy functions

# Minimum Image Distance function and Pair Dispersion Energy calculation (Code 3)
def minimum_image_distance(r_ij, cell_length):
    return r_ij - cell_length * np.round(r_ij / cell_length)

# pairwise dispersion energy operation
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def pair_dispersion_energy(system_data, configuration, force_field):
    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    total_dispersion_energy = 0.0
    num_atoms = len(positions)

    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            r_ij = positions[i] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)

            if 0 < distance < cutoff:
                type_i = atom_types[i]
                type_j = atom_types[j]
                if type_i not in force_field.index or type_j not in force_field.index:
                    continue

                epsilon_i = force_field.loc[type_i, 'epsilon']
                epsilon_j = force_field.loc[type_j, 'epsilon']
                sigma_i = force_field.loc[type_i, 'sigma']
                sigma_j = force_field.loc[type_j, 'sigma']

                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)
                sigma_ij = 0.5 * (sigma_i + sigma_j)
                s_over_r = sigma_ij / distance
                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)
                total_dispersion_energy += lj_pot

    return total_dispersion_energy

# Compute LRC energy
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_lrc_energy(system_row, force_field):
    U_lrc_total = 0.0
    cutoff = system_row['cutoff']

    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],
                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])
    volume = abs(np.linalg.det(h))

    for atom_type, atom_data in force_field.iterrows():
        num_particles = system_row['number of particles'] * atom_data['num_particles']
        rho = num_particles / volume
        sigma = atom_data['sigma']
        epsilon = atom_data['epsilon']

        if cutoff > 0:
            sc3 = (sigma / cutoff)**3
            sc9 = sc3**3
        else:
            sc3, sc9 = 0.0, 0.0

        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)
        U_lrc *= num_particles
        U_lrc_total += U_lrc

    return U_lrc_total

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def compute_real_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    cutoff = system_data[""cutoff""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    mol_ids = configuration[""Molecule""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])

    real_energy = 0.0
    n_atoms = len(positions)

    for j in range(n_atoms - 1):
        for l in range(j + 1, n_atoms):
            if mol_ids[j] == mol_ids[l]:
                continue
            r_ij = positions[l] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)
            if 1e-14 < distance < cutoff:
                q_j = charges[j]*e_charge
                q_l = charges[l]*e_charge
                r_m = distance*1e-10
                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)

    return real_energy

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_fourier_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data[""alpha""]
    kmax = system_data[""kmax""]

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)
    V_m = abs(np.linalg.det(h))*(1e-10**3)

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration[""Atom Type""].values
    charges = np.array([force_field.loc[t, ""charge""] for t in atom_types])
    charges_c = charges*e_charge

    positions_m = positions*1e-10
    prefactor = coulomb_factor/(2.0*V_m)

    alpha_m = alpha*1e10
    fourier_energy = 0.0

    max_sq = kmax*kmax + 2
    L_avg = (a + b + c)/3.0
    kfactor = 2.0*math.pi/(L_avg*1e-10)

    for kx in range(-kmax, kmax+1):
        for ky in range(-kmax, kmax+1):
            for kz in range(-kmax, kmax+1):
                if (kx == 0 and ky == 0 and kz == 0):
                    continue
                if (kx*kx + ky*ky + kz*kz) >= max_sq:
                    continue

                kx_m = kfactor*kx
                ky_m = kfactor*ky
                kz_m = kfactor*kz
                k_sq = kx_m**2 + ky_m**2 + kz_m**2
                if k_sq < 1e-14:
                    continue

                real_part = 0.0
                imag_part = 0.0
                for j, (xj, yj, zj) in enumerate(positions_m):
                    kr = kx_m*xj + ky_m*yj + kz_m*zj
                    real_part += charges_c[j]*math.cos(kr)
                    imag_part += charges_c[j]*math.sin(kr)

                sk_sq = real_part**2 + imag_part**2
                exp_factor = math.exp(-k_sq/(4.0*alpha_m**2))

                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq
                fourier_energy += term

    return fourier_energy


def compute_self_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    alpha_m = alpha*1e10
    sum_q2 = np.sum(charges_c**2)

    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2
    return self_energy


def compute_intra_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']

    positions = configuration[[""X"", ""Y"", ""Z""]].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    unique_mols = np.unique(mol_ids)
    intra_energy = 0.0

    for m_id in unique_mols:
        idxs = np.where(mol_ids == m_id)[0]
        for i in range(len(idxs) - 1):
            for j in range(i + 1, len(idxs)):
                idx_i = idxs[i]
                idx_j = idxs[j]
                dx = positions[idx_j, 0] - positions[idx_i, 0]
                dy = positions[idx_j, 1] - positions[idx_i, 1]
                dz = positions[idx_j, 2] - positions[idx_i, 2]
                r = math.sqrt(dx**2 + dy**2 + dz**2)
                if r > 1e-14:
                    q_i = charges[idx_i]*e_charge
                    q_j = charges[idx_j]*e_charge
                    r_m = r*1e-10
                    erf_val = erf(alpha*r)
                    # negative sign for intramolecular
                    val = coulomb_factor*(q_i*q_j/r_m)*erf_val
                    intra_energy -= val

    return intra_energy


# DataFrame Descriptions:

# 1. NIST_TRICLINIC_SPC_E_Water DataFrame:
#    - Contains thermodynamic properties of SPC/E water configurations in both triclinic and monoclinic cells.
#    - Columns:
#        - 'Configuration' (int): Configuration ID (1-4).
#        - 'M (number of SPC/E molecules)' (int): Number of SPC/E molecules in the system.
#        - 'Cell Type' (str): Type of the cell (e.g., Triclinic, Monoclinic).
#        - 'Cell Side Lengths [a, b, c] (Å)' (list of strings): Cell side lengths in Ångströms.
#        - 'Cell Angles [α, β, γ] (degrees)' (list of strings): Cell angles in degrees.
#        - 'Number of Wave Vectors' (int): The number of wave vectors for each configuration.
#        - 'Edisp/kB (K)' (float): Dispersion energy in Kelvin.
#        - 'ELRC/kB (K)' (float): Long-range correction energy in Kelvin.
#        - 'Ereal/kB (K)' (float): Real energy in Kelvin.
#        - 'Efourier/kB (K)' (float): Fourier transform energy in Kelvin.
#        - 'Eself/kB (K)' (float): Self-interaction energy in Kelvin.
#        - 'Eintra/kB (K)' (float): Intra-molecular energy in Kelvin.
#        - 'Etotal/kB (K)' (float): Total energy in Kelvin.

# 2. force_field DataFrame:
#    - Contains force field parameters for SPC/E water, specifically for oxygen ('O') and hydrogen ('H').
#    - Columns:
#        - 'type' (str): Atom type ('O' or 'H').
#        - 'sigma' (float): Lennard-Jones parameter (Å).
#        - 'epsilon' (float): Lennard-Jones well depth (K).
#        - 'charge' (float): Partial charge (e).
#        - 'num_particles' (int): Number of particles per molecule.

# 3. system DataFrame:
#    - Contains metadata about each system configuration.
#    - Columns:
#        - 'file_paths' (str): File names containing atomic configurations.
#        - 'configuration #' (int): Extracted configuration number (1-4).
#        - 'number of particles' (float): Number of molecules (from 'NIST_SPC_E_Water').
#        - 'box length' (float): Box dimensions (from 'NIST_SPC_E_Water').
#        - 'cutoff' (int): Fixed cutoff distance for interactions (10 Å).
#        - 'alpha' (float): Ewald summation parameter (5.6 / min(a, b, c)).
#        - 'kmax' (int): Maximum wave vector index (5); also, only include k for which k² < kmax² + 2, i.e., k² < 27.
#        - 'ε0' (float): Permittivity of Vacuum (8.854187817E-12 C²/(J m)).
#        - 'kB' (float): Boltzmann Constant (1.3806488E-23 J/K).

# 4. configuration DataFrame (from 'extracting_positions'):
#    - Created per file, containing atomic positions.
#    - Columns:
#        - 'X' (float): Atom coordinates in Ångströms.
#        - 'Y' (float): Atom coordinates in Ångströms.
#        - 'Z' (float): Atom coordinates in Ångströms.
#        - 'Atom Type' (str): Type of atom ('O' or 'H').
#        - 'Molecule' (int): Molecule index assigned based on position.


system, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties,NIST_TRICLINIC_SPC_E_Water)

# Computing energies storing in results
results = pd.DataFrame()

results['Number of Particles'] = system['number of particles'].astype(int)

# Calculate LRC energy for all system configurations
results['lrc_Energies'] = system.apply(
    lambda row: compute_lrc_energy(row, force_field), axis=1
)

# Calculate pairwise energy for all system configurations
results['dispersion_energies'] = system['file_paths'].apply(
    lambda file_path: pair_dispersion_energy(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path), 
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['real_energies'] = system['file_paths'].apply(
    lambda file_path: compute_real_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['fourier_energies'] = system['file_paths'].apply(
    lambda file_path: compute_fourier_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['self_energies'] = system['file_paths'].apply(
    lambda file_path: compute_self_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['intra_energies'] = system['file_paths'].apply(
    lambda file_path: compute_intra_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

def compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):
    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')

    matched_real = matched_fourier = matched_self = matched_intra = 0
    matched_dispersion = matched_lrc = 0
    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0
    not_matched_dispersion = not_matched_lrc = 0
    l2_dispersion = l2_lrc = l2_real = 0.0
    l2_fourier = l2_self = l2_intra = 0.0

    real_energy_output = []
    fourier_energy_output = []
    self_energy_output = []
    intra_energy_output = []
    lrc_energy_output = []
    dispersion_energy_output = []

    for idx, row in df_merged.iterrows():
        real_energy = row['real_energies']
        fourier_energy = row['fourier_energies']
        self_energy = row['self_energies']
        intra_energy = row['intra_energies']
        num_molecules = row['Number of Particles']
        lrc_energy = row['lrc_Energies']
        dispersion_energy = row['dispersion_energies']

        if pd.isna(row['Ereal/kB (K)']):
            continue
        nist_real_energy = float(row['Ereal/kB (K)'])
        nist_fourier_energy = float(row['Efourier/kB (K)'])
        nist_self_energy = float(row['Eself/kB (K)'])
        nist_intra_energy = float(row['Eintra/kB (K)'])
        nist_lrc_energy = float(row['ELRC/kB (K)'])
        nist_dispersion_energy = float(row['Edisp/kB (K)'])

        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)
        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)
        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)
        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)
        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)
        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)

        matched_real += int(match_real)
        not_matched_real += int(not match_real)
        matched_fourier += int(match_fourier)
        not_matched_fourier += int(not match_fourier)
        matched_self += int(match_self)
        not_matched_self += int(not match_self)
        matched_intra += int(match_intra)
        not_matched_intra += int(not match_intra)
        matched_dispersion += int(match_dispersion)
        not_matched_dispersion += int(not match_dispersion)
        matched_lrc += int(match_lrc)
        not_matched_lrc += int(not match_lrc)

        dispersion_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}"")
        lrc_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}"")
        real_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}"")
        fourier_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}"")
        self_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}"")
        intra_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}"")

        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)
        l2_lrc = np.square(lrc_energy - nist_lrc_energy)
        l2_real = np.square(real_energy - nist_real_energy)
        l2_fourier = np.square(fourier_energy - nist_fourier_energy)
        l2_self = np.square(self_energy - nist_self_energy)
        l2_intra = np.square(intra_energy - nist_intra_energy)

    print()
    print(""Lennard-Jones Pair Dispersion Energy Comparison:"")
    print(*dispersion_energy_output)
    print(""Lennard-Jones long-range corrections Energy Comparison:"")
    print(*lrc_energy_output)
    print(""Real Energy Comparison:"")
    print(*real_energy_output)
    print(""Fourier Energy Comparison:"")
    print(*fourier_energy_output)
    print(""Self Energy Comparison:"")
    print(*self_energy_output)
    print(""Intra Energy Comparison:"")
    print(*intra_energy_output)
    print()
    print(f""Count of correct pairwise answers: {matched_dispersion}"")
    print(f""Count of incorrect pairwise answers: {not_matched_dispersion}"")
    print(f""Count of correct LRC answers: {matched_lrc}"")
    print(f""Count of incorrect LRC answers: {not_matched_lrc}"")
    print(f""Count of correct Real Energy answers: {matched_real}"")
    print(f""Count of incorrect Real Energy answers: {not_matched_real}"")
    print(f""Count of correct Fourier Energy answers: {matched_fourier}"")
    print(f""Count of incorrect Fourier Energy answers: {not_matched_fourier}"")
    print(f""Count of correct Self Energy answers: {matched_self}"")
    print(f""Count of incorrect Self Energy answers: {not_matched_self}"")
    print(f""Count of correct Intra Energy answers: {matched_intra}"")
    print(f""Count of incorrect Intra Energy answers: {not_matched_intra}"")
    print()
    print(f""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}"")
    print(f""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}"")
    print(f""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}"")
    print(f""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}"")
    print(f""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}"")
    print(f""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}"")
    print(f""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}"")
    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc
    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc
    print(f""Total correct answers: {total_correct}"")
    print(f""Total incorrect answers: {total_incorrect}"")


# calling compare_coulomb_energy function
compare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)


Context:
Illustration of input file format:

            3.000000000000e+01       3.000000000000e+01       3.000000000000e+01
            8.500000000000e+01       7.500000000000e+01       8.000000000000e+01
         200
    1      -1.073606597760e+01       1.432194046140e+01      -6.226901963110e+00    O
    2      -1.661030970030e+01      -1.461065205480e+01      -5.798020258290e+00    H
    3      -1.118063417070e+01       1.380841402440e+01      -6.960829561930e+00    H
    4      -1.377161709910e+01      -8.711236583990e+00      -1.350200277380e+01    O
    5      -1.347193958490e+01      -8.247621904110e+00      -1.433582218840e+01    H
   
Formula for the potential energy for the SPC/E model of water(latex form):

\Large E_{total}\left( \mathbf{r}^N \right) = E_{disp}\left( \mathbf{r}^N \right) + E_{LRC} + E_{coulomb}\left( \mathbf{r}^N \right)

The terms on the right-hand side of the equality to be computed are:

1) The pair dispersion energy

2) The long-range correction to the pair dispersion energy

3) The Coulombic potential energy

Formula for the Coulombic potential energy(latex form):

\Large \begin{eqnarray} E_{coulomb}\left(\mathbf{r}^N\right) & = &
\sum\limits_{j}  \sum\limits_{l>j}
\dfrac{q_j q_l}{ 4 \pi \epsilon_0} \dfrac{\text{erfc}\left(\alpha \cdot  \left| \mathbf{r}_{jl} \right| \right)}{\left| \mathbf{r}_{jl} \right|} \Theta\left( r_{cut} - \left|\mathbf{r}_{jl}\right| \right) \\
&& +\dfrac{1}{2 \pi V} \sum\limits_{\mathbf{k} \neq \mathbf{0}} \dfrac{1}{k^2} \exp \left[-\left( \dfrac{\pi k}{\alpha} \right)^2 \right] \dfrac{1}{4 \pi \epsilon_0} \cdot \left|\sum\limits_{j=1}^N q_j \exp \left(2\pi i \mathbf{k} \cdot \mathbf{r}_j \right) \right|^2 \\
&& - \dfrac{\alpha}{\sqrt{\pi}} \sum\limits_j \dfrac{q_j^2}{4 \pi \epsilon_0} \\
&& - \sum\limits_{j=1}^M  \sum\limits_{\kappa}  \sum\limits_{\lambda>\kappa} \dfrac{q_{j_\kappa} q_{j_\lambda}}{ 4 \pi \epsilon_0} \dfrac{\text{erf}\left(\alpha \cdot  \left| \mathbf{r}_{j_\kappa j_\lambda} \right| \right)}{\left| \mathbf{r}_{j_\kappa j_\lambda} \right|}
\end{eqnarray}

The Coulombic energy is computed using the Ewald Summation Method. The terms on the right hand side of the equality are

1) The real-space term Ereal,

2) The Fourier-space term, Efourier,

3) The self-correction term Eself,

4) The intramolecular term Eintra.

Primary task:

Modify the functions in the code above, considering the input format.

Incorporate any additional functions that might be required.

Make the necessary changes to the dataframes to accommodate the updated input format.

You may access the required columns from the given dataframes as parameters to the function to calculate the energies.

You may modify other parts of the code, except the compare_LJ_coulomb_energy function.

Strict Requirements:

Do not modify the function names or parameters.

The output should always include Python code for modifying the respective functions.

The compare_LJ_coulomb_energy function should remain unchanged, as it controls the iteration loop.

Ensure that the print statements in the compare_LJ_coulomb_energy function remain exactly as they are, even as you make modifications to the other functions.

Iteration Notes: 

If multiple functions are provided to solve the task, work through them one by one in each iteration.

The iteration loop will continue until the desired outcome is achieved.

Output Format:

Produce a JSON output in the following format:
  ""Reasoning"": """",
  ""Code"": """"

Ensure that:
1. The JSON output is **properly formatted** with **double quotes** around keys.
2. The **Reasoning** section provides a concise and clear explanation of the approach taken.
3. The **Code** section contains well-structured, indented, and syntactically correct Python (or the required language).
4. The JSON output does **not** contain extraneous symbols such as triple backticks (` ``` `) or markdown indicators.
5. The output should be **fully valid JSON** and parseable using `json.loads()`.

Feedback Integration: 

When feedback is provided, ensure you proceed with the next steps based on the iteration results and the correct answers generated. Focus on the L2 score to reduce errors.


Result from the code generated:

            Your code resulted in the following error from 0 iterations. The threshold is 3. Resolve the error before the 3rd attempt:
            Error
            Traceback (most recent call last):
  File ""<string>"", line 557, in <module>
  File ""<string>"", line 110, in creating_dataframes
KeyError: 'a' 
            Review the specific part or function causing the error in the next iteration and correct it.
            ","{
  ""Reasoning"": ""The KeyError 'a' indicates that the code references configuration.attrs['a'], but the first three lines of the input file (containing a, b, c, α, β, γ, and M) were never parsed or stored as attributes. In the extracting_positions function, we now parse the first three lines for those parameters, assign them to configuration.attrs, and then read the atomic data from line 4 onward. This ensures that a, b, c, α, β, and γ are available when creating the system DataFrame."",
  ""Code"": ""import numpy as np\nimport pandas as pd\nfrom scipy.special import erfc, erf\nimport math\n\n# defining all variables\natom_properties = {\n    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},\n    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},\n}\n\n# Trying for small configurations first\nfile_paths = [\n    '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'\n]\n\nNIST_TRICLINIC_SPC_E_Water = {\n    'Configuration': [1, 2, 3, 4],\n    'M (number of SPC/E molecules)': [400, 300, 200, 100],\n    'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],\n    'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]', '[27 Å, 30 Å, 36 Å]', '[30 Å, 30 Å, 30 Å]', '[36 Å, 36 Å, 36 Å]'],\n    'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]', '[90°, 75°, 90°]', '[85°, 75°, 80°]', '[90°, 60°, 90°]'],\n    'Number of Wave Vectors': [831, 1068, 838, 1028],\n    'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],\n    'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],\n    'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],\n    'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],\n    'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],\n    'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],\n    'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]\n}\n\n# 1) Updated extracting_positions to parse first three lines for box parameters (a,b,c, alpha,beta,gamma) and M.\ndef extracting_positions(input_file):\n    with open(input_file, 'r') as file:\n        lines = file.readlines()\n\n    # First line => a, b, c\n    line0 = lines[0].split()\n    a = float(line0[0])\n    b = float(line0[1])\n    c = float(line0[2])\n\n    # Second line => alpha, beta, gamma\n    line1 = lines[1].split()\n    alpha_deg = float(line1[0])\n    beta_deg = float(line1[1])\n    gamma_deg = float(line1[2])\n\n    # Third line => M\n    line2 = lines[2].split()\n    M = int(line2[0])\n\n    # Remaining lines => atomic data\n    data_lines = lines[3:]\n\n    data_list = []\n    for line in data_lines:\n        stripped_line = line.strip()\n        parts = stripped_line.split()\n        if len(parts) >= 5:\n            try:\n                x, y, z = map(float, parts[1:4])\n                atom_type = parts[4]\n                data_list.append([x, y, z, atom_type])\n            except ValueError:\n                continue\n\n    columns = ['X', 'Y', 'Z', 'Atom Type']\n    configuration = pd.DataFrame(data_list, columns=columns)\n    configuration.index = range(1, len(configuration) + 1)\n\n    # Molecule indexing\n    configuration['Molecule'] = ((configuration.index - 1) // 3) + 1\n\n    # Store box info\n    configuration.attrs['a'] = a\n    configuration.attrs['b'] = b\n    configuration.attrs['c'] = c\n    configuration.attrs['alpha_deg'] = alpha_deg\n    configuration.attrs['beta_deg'] = beta_deg\n    configuration.attrs['gamma_deg'] = gamma_deg\n    configuration.attrs['M'] = M\n\n    return configuration\n\n# parse_cell_sides and parse_cell_angles remain, but are not used in the final approach.\ndef parse_cell_sides(sides_str):\n    sides_str = sides_str.strip().strip('[]')\n    parts = sides_str.split(',')\n    values = []\n    for p in parts:\n        p = p.strip().replace('Å', '')\n        values.append(float(p))\n    return values\n\ndef parse_cell_angles(angles_str):\n    angles_str = angles_str.strip().strip('[]')\n    parts = angles_str.split(',')\n    values = []\n    for p in parts:\n        p = p.strip().replace('°', '')\n        values.append(float(p))\n    return values\n\n# 2) creating_dataframes function uses the box data from configuration.attrs\n\ndef creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):\n    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)\n    NIST_SPC_E_Water['Sum of energies'] = (\n        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +\n        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +\n        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']\n    )\n\n    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')\n\n    system_rows = []\n    for file_path in file_paths:\n        config_temp = extracting_positions(file_path)\n        a = config_temp.attrs['a']\n        b = config_temp.attrs['b']\n        c = config_temp.attrs['c']\n        alpha_deg = config_temp.attrs['alpha_deg']\n        beta_deg = config_temp.attrs['beta_deg']\n        gamma_deg = config_temp.attrs['gamma_deg']\n        M = config_temp.attrs['M']\n\n        import re\n        match_conf = re.search(r'(\\d+)', file_path)\n        conf_num = int(match_conf.group(1)) if match_conf else 0\n\n        system_dict = {\n            'file_paths': file_path,\n            'configuration #': conf_num,\n            'number of particles': float(M),\n            'a': a,\n            'b': b,\n            'c': c,\n            'alpha_deg': alpha_deg,\n            'beta_deg': beta_deg,\n            'gamma_deg': gamma_deg\n        }\n        system_rows.append(system_dict)\n\n    system = pd.DataFrame(system_rows)\n\n    system['cutoff'] = 10.0\n\n    def alpha_value(row):\n        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28\n\n    system['alpha'] = system.apply(alpha_value, axis=1)\n\n    system['kmax'] = 5\n    system['ε0'] = float(8.854187817e-12)\n    system['kB'] = float(1.3806488e-23)\n\n    return system, force_field, NIST_SPC_E_Water\n\n# Minimum image for cubic (unused), left for reference.\ndef minimum_image_distance(r_ij, cell_length):\n    return r_ij - cell_length * np.round(r_ij / cell_length)\n\n# 3) Build the triclinic matrix\n\ndef build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):\n    alpha = math.radians(alpha_deg)\n    beta = math.radians(beta_deg)\n    gamma = math.radians(gamma_deg)\n\n    ax = a\n    ay = 0.0\n    az = 0.0\n\n    bx = b * math.cos(gamma)\n    by = b * math.sin(gamma)\n    bz = 0.0\n\n    sin_gamma = math.sin(gamma)\n    cx = c * math.cos(beta)\n    if abs(sin_gamma) < 1e-14:\n        sin_gamma = 1e-14\n    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)\n    cz = math.sqrt(c**2 - cx**2 - cy**2)\n\n    h = np.array([\n        [ax, bx, cx],\n        [ay, by, cy],\n        [az, bz, cz]\n    ], dtype=float)\n\n    h_inv = np.linalg.inv(h)\n    return h, h_inv\n\ndef min_image_distance_triclinic(r_ij, h, h_inv):\n    frac = h_inv.dot(r_ij)\n    frac -= np.round(frac)\n    return h.dot(frac)\n\n# 4) Pairwise dispersion\n\ndef pair_dispersion_energy(system_data, configuration, force_field):\n    positions = configuration[['X', 'Y', 'Z']].values\n    atom_types = configuration['Atom Type'].values\n    cutoff = system_data['cutoff']\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n\n    total_dispersion_energy = 0.0\n    num_atoms = len(positions)\n\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            r_ij = positions[i] - positions[j]\n            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)\n            distance = np.linalg.norm(r_ij)\n\n            if 0 < distance < cutoff:\n                type_i = atom_types[i]\n                type_j = atom_types[j]\n                if type_i not in force_field.index or type_j not in force_field.index:\n                    continue\n\n                epsilon_i = force_field.loc[type_i, 'epsilon']\n                epsilon_j = force_field.loc[type_j, 'epsilon']\n                sigma_i = force_field.loc[type_i, 'sigma']\n                sigma_j = force_field.loc[type_j, 'sigma']\n\n                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)\n                sigma_ij = 0.5 * (sigma_i + sigma_j)\n                s_over_r = sigma_ij / distance\n                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)\n                total_dispersion_energy += lj_pot\n\n    return total_dispersion_energy\n\n# 5) LRC\n\ndef compute_lrc_energy(system_row, force_field):\n    U_lrc_total = 0.0\n    cutoff = system_row['cutoff']\n\n    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],\n                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])\n    volume = abs(np.linalg.det(h))\n\n    for atom_type, atom_data in force_field.iterrows():\n        num_particles = system_row['number of particles'] * atom_data['num_particles']\n        rho = num_particles / volume\n        sigma = atom_data['sigma']\n        epsilon = atom_data['epsilon']\n\n        if cutoff > 0:\n            sc3 = (sigma / cutoff)**3\n            sc9 = sc3**3\n        else:\n            sc3, sc9 = 0.0, 0.0\n\n        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)\n        U_lrc *= num_particles\n        U_lrc_total += U_lrc\n\n    return U_lrc_total\n\n# 6) Real-space term\n\ndef compute_real_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n    cutoff = system_data['cutoff']\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n\n    positions = configuration[['X', 'Y', 'Z']].values\n    atom_types = configuration['Atom Type'].values\n    mol_ids = configuration['Molecule'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n\n    real_energy = 0.0\n    n_atoms = len(positions)\n\n    for j in range(n_atoms - 1):\n        for l in range(j + 1, n_atoms):\n            if mol_ids[j] == mol_ids[l]:\n                continue\n            r_ij = positions[l] - positions[j]\n            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)\n            distance = np.linalg.norm(r_ij)\n            if 1e-14 < distance < cutoff:\n                q_j = charges[j]*e_charge\n                q_l = charges[l]*e_charge\n                r_m = distance*1e-10\n                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)\n\n    return real_energy\n\n# 7) Fourier-space term\n\ndef compute_fourier_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n    kmax = system_data['kmax']\n\n    a = system_data['a']\n    b = system_data['b']\n    c = system_data['c']\n    alpha_deg = system_data['alpha_deg']\n    beta_deg = system_data['beta_deg']\n    gamma_deg = system_data['gamma_deg']\n\n    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)\n    V_m = abs(np.linalg.det(h))*(1e-10**3)\n\n    positions = configuration[['X', 'Y', 'Z']].values\n    atom_types = configuration['Atom Type'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n    charges_c = charges*e_charge\n\n    positions_m = positions*1e-10\n    prefactor = coulomb_factor/(2.0*V_m)\n\n    alpha_m = alpha*1e10\n    fourier_energy = 0.0\n\n    max_sq = kmax*kmax + 2\n    L_avg = (a + b + c)/3.0\n    kfactor = 2.0*math.pi/(L_avg*1e-10)\n\n    for kx in range(-kmax, kmax+1):\n        for ky in range(-kmax, kmax+1):\n            for kz in range(-kmax, kmax+1):\n                if (kx == 0 and ky == 0 and kz == 0):\n                    continue\n                if (kx*kx + ky*ky + kz*kz) >= max_sq:\n                    continue\n\n                kx_m = kfactor*kx\n                ky_m = kfactor*ky\n                kz_m = kfactor*kz\n                k_sq = kx_m**2 + ky_m**2 + kz_m**2\n                if k_sq < 1e-14:\n                    continue\n\n                real_part = 0.0\n                imag_part = 0.0\n                for j, (xj, yj, zj) in enumerate(positions_m):\n                    kr = kx_m*xj + ky_m*yj + kz_m*zj\n                    real_part += charges_c[j]*math.cos(kr)\n                    imag_part += charges_c[j]*math.sin(kr)\n\n                sk_sq = real_part**2 + imag_part**2\n                exp_factor = math.exp(-k_sq/(4.0*alpha_m**2))\n\n                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq\n                fourier_energy += term\n\n    return fourier_energy\n\n# 8) Self term\n\ndef compute_self_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n    atom_types = configuration['Atom Type'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n    charges_c = charges*e_charge\n\n    alpha_m = alpha*1e10\n    sum_q2 = np.sum(charges_c**2)\n\n    # standard Ewald self\n    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2\n    return self_energy\n\n# 9) Intra term\n\ndef compute_intra_energies(system_data, configuration, force_field):\n    e_charge = 1.602176634e-19\n    coulomb_factor = 8.9875517923e9 / 1.3806488e-23\n\n    alpha = system_data['alpha']\n\n    positions = configuration[['X', 'Y', 'Z']].values\n    atom_types = configuration['Atom Type'].values\n    mol_ids = configuration['Molecule'].values\n    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])\n\n    unique_mols = np.unique(mol_ids)\n    intra_energy = 0.0\n\n    for m_id in unique_mols:\n        idxs = np.where(mol_ids == m_id)[0]\n        for i in range(len(idxs) - 1):\n            for j in range(i + 1, len(idxs)):\n                idx_i = idxs[i]\n                idx_j = idxs[j]\n                dx = positions[idx_j, 0] - positions[idx_i, 0]\n                dy = positions[idx_j, 1] - positions[idx_i, 1]\n                dz = positions[idx_j, 2] - positions[idx_i, 2]\n                r = math.sqrt(dx**2 + dy**2 + dz**2)\n                if r > 1e-14:\n                    q_i = charges[idx_i]*e_charge\n                    q_j = charges[idx_j]*e_charge\n                    r_m = r*1e-10\n                    erf_val = erf(alpha*r)\n                    # negative sign for intramolecular\n                    val = coulomb_factor*(q_i*q_j / r_m)*erf_val\n                    intra_energy -= val\n\n    return intra_energy\n\n# Build the system, force_field, NIST data\nsystem, force_field, NIST_SPC_E_Water = creating_dataframes(file_paths, atom_properties, NIST_TRICLINIC_SPC_E_Water)\n\n# Compute and store results\nresults = pd.DataFrame()\n\nresults['Number of Particles'] = system['number of particles'].astype(int)\n\nresults['lrc_Energies'] = system.apply(\n    lambda row: compute_lrc_energy(row, force_field), axis=1\n)\n\nresults['dispersion_energies'] = system['file_paths'].apply(\n    lambda file_path: pair_dispersion_energy(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['real_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_real_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['fourier_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_fourier_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['self_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_self_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\nresults['intra_energies'] = system['file_paths'].apply(\n    lambda file_path: compute_intra_energies(\n        system[system['file_paths'] == file_path].iloc[0],\n        extracting_positions(file_path),\n        force_field\n    )\n)\n\ndef compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):\n    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')\n\n    matched_real = matched_fourier = matched_self = matched_intra = 0\n    matched_dispersion = matched_lrc = 0\n    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0\n    not_matched_dispersion = not_matched_lrc = 0\n    l2_dispersion = l2_lrc = l2_real = 0.0\n    l2_fourier = l2_self = l2_intra = 0.0\n\n    real_energy_output = []\n    fourier_energy_output = []\n    self_energy_output = []\n    intra_energy_output = []\n    lrc_energy_output = []\n    dispersion_energy_output = []\n\n    for idx, row in df_merged.iterrows():\n        real_energy = row['real_energies']\n        fourier_energy = row['fourier_energies']\n        self_energy = row['self_energies']\n        intra_energy = row['intra_energies']\n        num_molecules = row['Number of Particles']\n        lrc_energy = row['lrc_Energies']\n        dispersion_energy = row['dispersion_energies']\n\n        if pd.isna(row['Ereal/kB (K)']):\n            continue\n        nist_real_energy = float(row['Ereal/kB (K)'])\n        nist_fourier_energy = float(row['Efourier/kB (K)'])\n        nist_self_energy = float(row['Eself/kB (K)'])\n        nist_intra_energy = float(row['Eintra/kB (K)'])\n        nist_lrc_energy = float(row['ELRC/kB (K)'])\n        nist_dispersion_energy = float(row['Edisp/kB (K)'])\n\n        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)\n        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)\n        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)\n        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)\n        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)\n        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)\n\n        matched_real += int(match_real)\n        not_matched_real += int(not match_real)\n        matched_fourier += int(match_fourier)\n        not_matched_fourier += int(not match_fourier)\n        matched_self += int(match_self)\n        not_matched_self += int(not match_self)\n        matched_intra += int(match_intra)\n        not_matched_intra += int(not match_intra)\n        matched_dispersion += int(match_dispersion)\n        not_matched_dispersion += int(not match_dispersion)\n        matched_lrc += int(match_lrc)\n        not_matched_lrc += int(not match_lrc)\n\n        dispersion_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}\"")\n        lrc_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}\"")\n        real_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}\"")\n        fourier_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}\"")\n        self_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}\"")\n        intra_energy_output.append(f\""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}\"")\n\n        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)\n        l2_lrc = np.square(lrc_energy - nist_lrc_energy)\n        l2_real = np.square(real_energy - nist_real_energy)\n        l2_fourier = np.square(fourier_energy - nist_fourier_energy)\n        l2_self = np.square(self_energy - nist_self_energy)\n        l2_intra = np.square(intra_energy - nist_intra_energy)\n\n    print()\n    print(\""Lennard-Jones Pair Dispersion Energy Comparison:\"")\n    print(*dispersion_energy_output)\n    print(\""Lennard-Jones long-range corrections Energy Comparison:\"")\n    print(*lrc_energy_output)\n    print(\""Real Energy Comparison:\"")\n    print(*real_energy_output)\n    print(\""Fourier Energy Comparison:\"")\n    print(*fourier_energy_output)\n    print(\""Self Energy Comparison:\"")\n    print(*self_energy_output)\n    print(\""Intra Energy Comparison:\"")\n    print(*intra_energy_output)\n    print()\n    print(f\""Count of correct pairwise answers: {matched_dispersion}\"")\n    print(f\""Count of incorrect pairwise answers: {not_matched_dispersion}\"")\n    print(f\""Count of correct LRC answers: {matched_lrc}\"")\n    print(f\""Count of incorrect LRC answers: {not_matched_lrc}\"")\n    print(f\""Count of correct Real Energy answers: {matched_real}\"")\n    print(f\""Count of incorrect Real Energy answers: {not_matched_real}\"")\n    print(f\""Count of correct Fourier Energy answers: {matched_fourier}\"")\n    print(f\""Count of incorrect Fourier Energy answers: {not_matched_fourier}\"")\n    print(f\""Count of correct Self Energy answers: {matched_self}\"")\n    print(f\""Count of incorrect Self Energy answers: {not_matched_self}\"")\n    print(f\""Count of correct Intra Energy answers: {matched_intra}\"")\n    print(f\""Count of incorrect Intra Energy answers: {not_matched_intra}\"")\n    print()\n    print(f\""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}\"")\n    print(f\""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}\"")\n    print(f\""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}\"")\n    print(f\""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}\"")\n    print(f\""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}\"")\n    print(f\""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}\"")\n    print(f\""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}\"")\n    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc\n    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc\n    print(f\""Total correct answers: {total_correct}\"")\n    print(f\""Total incorrect answers: {total_incorrect}\"")\n\ncompare_LJ_coulomb_energy(results, NIST_SPC_E_Water)\n""
}","import numpy as np
import pandas as pd
from scipy.special import erfc,erf
import math 

# defining all variables
atom_properties = {
    'O': {'type': 'O', 'sigma': 3.165558, 'epsilon': 78.197431, 'charge': -0.8476, 'num_particles': 1},
    'H': {'type': 'H', 'sigma': 0.000000, 'epsilon': 0.000000, 'charge': 0.4238, 'num_particles': 2},
}

# Trying for small configurations first
file_paths = [
    #    '../data/spce_sample_config_periodic4.txt',
    #    '../data/spce_sample_config_periodic2.txt',
    #    '../data/spce_sample_config_periodic3.txt',
        '../data/spce-sample-non-cuboid-configurations/spce_triclinic_sample_periodic3.txt'
    ]

NIST_TRICLINIC_SPC_E_Water = {'Configuration': [1, 2, 3, 4],
 'M (number of SPC/E molecules)': [400, 300, 200, 100],
 'Cell Type': ['Triclinic', 'Monoclinic', 'Triclinic', 'Monoclinic'],
 'Cell Side Lengths [a, b, c] (Å)': ['[30 Å, 30 Å, 30 Å]',
  '[27 Å, 30 Å, 36 Å]',
  '[30 Å, 30 Å, 30 Å]',
  '[36 Å, 36 Å, 36 Å]'],
 'Cell Angles [α, β, γ] (degrees)': ['[100°, 95°, 75°]',
  '[90°, 75°, 90°]',
  '[85°, 75°, 80°]',
  '[90°, 60°, 90°]'],
 'Number of Wave Vectors': [831, 1068, 838, 1028],
 'Edisp/kB (K)': [111992.0, 43286.0, 14403.3, 25025.1],
 'ELRC/kB (K)': [-4109.19, -2105.61, -1027.3, -163.091],
 'Ereal/kB (K)': [-727219.0, -476902.0, -297129.0, -171462.0],
 'Efourier/kB (K)': [44677.0, 44409.4, 28897.4, 22337.2],
 'Eself/kB (K)': [-11582000.0, -8686470.0, -5790980.0, -2895490.0],
 'Eintra/kB (K)': [11435400.0, 8576520.0, 5717680.0, 2858840.0],
 'Etotal/kB (K)': [-721254.0, -501259.0, -328153.0, -160912.0]}

# Data processing







def extracting_positions(input_file):
        # Extract the positions from the .xyz file
    with open(input_file, ""r"") as file:
        lines = file.readlines()

    data_lines = lines[2:]

    data_list = []
    for line in data_lines:
        stripped_line = line.strip()
        parts = stripped_line.split()
        if len(parts) >= 5:  
            try:
                x, y, z = map(float, parts[1:4])
                atom_type = parts[4]
                data_list.append([x, y, z, atom_type])
            except ValueError:
                continue  

    # Create a DataFrame with all configurations
    columns = [""X"", ""Y"", ""Z"", ""Atom Type""]
    configuration = pd.DataFrame(data_list, columns=columns)

    configuration.index = range(1, len(configuration) + 1)

    configuration[""Molecule""] = ((configuration.index - 1) // 3) + 1
    
    return configuration

# create the target dataframes
def parse_cell_sides(sides_str):
    sides_str = sides_str.strip().strip('[]')
    parts = sides_str.split(',')
    values = []
    for p in parts:
        p = p.strip().replace('Å', '')
        values.append(float(p))
    return values

def parse_cell_angles(angles_str):
    angles_str = angles_str.strip().strip('[]')
    parts = angles_str.split(',')
    values = []
    for p in parts:
        p = p.strip().replace('°', '')
        values.append(float(p))
    return values

def creating_dataframes(file_paths, atom_properties, NIST_SPC_E_Water):
    NIST_SPC_E_Water = pd.DataFrame(NIST_SPC_E_Water)
    NIST_SPC_E_Water['Sum of energies'] = (
        NIST_SPC_E_Water['Edisp/kB (K)'] + NIST_SPC_E_Water['ELRC/kB (K)'] +
        NIST_SPC_E_Water['Ereal/kB (K)'] + NIST_SPC_E_Water['Efourier/kB (K)'] +
        NIST_SPC_E_Water['Eself/kB (K)'] + NIST_SPC_E_Water['Eintra/kB (K)']
    )

    force_field = pd.DataFrame(atom_properties).from_dict(atom_properties, orient='index')

    system_rows = []
    for file_path in file_paths:
        config_temp = extracting_positions(file_path)
        a = config_temp.attrs['a']
        b = config_temp.attrs['b']
        c = config_temp.attrs['c']
        alpha_deg = config_temp.attrs['alpha_deg']
        beta_deg = config_temp.attrs['beta_deg']
        gamma_deg = config_temp.attrs['gamma_deg']
        M = config_temp.attrs['M']

        import re
        match_conf = re.search(r'(\d+)', file_path)
        conf_num = int(match_conf.group(1)) if match_conf else 0

        system_dict = {
            'file_paths': file_path,
            'configuration #': conf_num,
            'number of particles': float(M),
            'a': a,
            'b': b,
            'c': c,
            'alpha_deg': alpha_deg,
            'beta_deg': beta_deg,
            'gamma_deg': gamma_deg
        }
        system_rows.append(system_dict)

    system = pd.DataFrame(system_rows)

    system['cutoff'] = 10.0

    def alpha_value(row):
        return 5.6 / min(row['a'], row['b'], row['c']) if (row['a'] > 0 and row['b'] > 0 and row['c'] > 0) else 0.28

    system['alpha'] = system.apply(alpha_value, axis=1)

    system['kmax'] = 5
    system['ε0'] = float(8.854187817e-12)
    system['kB'] = float(1.3806488e-23)

    return system, force_field, NIST_SPC_E_Water

# pairwise dispersion energy functions

# Minimum Image Distance function and Pair Dispersion Energy calculation (Code 3)
def minimum_image_distance(r_ij, cell_length):
    return r_ij - cell_length * np.round(r_ij / cell_length)

# pairwise dispersion energy operation
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def pair_dispersion_energy(system_data, configuration, force_field):
    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    total_dispersion_energy = 0.0
    num_atoms = len(positions)

    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            r_ij = positions[i] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)

            if 0 < distance < cutoff:
                type_i = atom_types[i]
                type_j = atom_types[j]
                if type_i not in force_field.index or type_j not in force_field.index:
                    continue

                epsilon_i = force_field.loc[type_i, 'epsilon']
                epsilon_j = force_field.loc[type_j, 'epsilon']
                sigma_i = force_field.loc[type_i, 'sigma']
                sigma_j = force_field.loc[type_j, 'sigma']

                epsilon_ij = math.sqrt(epsilon_i * epsilon_j)
                sigma_ij = 0.5 * (sigma_i + sigma_j)
                s_over_r = sigma_ij / distance
                lj_pot = 4.0 * epsilon_ij * (s_over_r**12 - s_over_r**6)
                total_dispersion_energy += lj_pot

    return total_dispersion_energy

# Compute LRC energy
def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_lrc_energy(system_row, force_field):
    U_lrc_total = 0.0
    cutoff = system_row['cutoff']

    h, _ = build_triclinic_matrix(system_row['a'], system_row['b'], system_row['c'],
                                  system_row['alpha_deg'], system_row['beta_deg'], system_row['gamma_deg'])
    volume = abs(np.linalg.det(h))

    for atom_type, atom_data in force_field.iterrows():
        num_particles = system_row['number of particles'] * atom_data['num_particles']
        rho = num_particles / volume
        sigma = atom_data['sigma']
        epsilon = atom_data['epsilon']

        if cutoff > 0:
            sc3 = (sigma / cutoff)**3
            sc9 = sc3**3
        else:
            sc3, sc9 = 0.0, 0.0

        U_lrc = (8.0 / 3.0)*math.pi*rho*epsilon*(sigma**3)*(sc9/3.0 - sc3)
        U_lrc *= num_particles
        U_lrc_total += U_lrc

    return U_lrc_total

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def min_image_distance_triclinic(r_ij, h, h_inv):
    frac = h_inv.dot(r_ij)
    frac -= np.round(frac)
    return h.dot(frac)

def compute_real_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    cutoff = system_data['cutoff']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, h_inv = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)

    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    real_energy = 0.0
    n_atoms = len(positions)

    for j in range(n_atoms - 1):
        for l in range(j + 1, n_atoms):
            if mol_ids[j] == mol_ids[l]:
                continue
            r_ij = positions[l] - positions[j]
            r_ij = min_image_distance_triclinic(r_ij, h, h_inv)
            distance = np.linalg.norm(r_ij)
            if 1e-14 < distance < cutoff:
                q_j = charges[j]*e_charge
                q_l = charges[l]*e_charge
                r_m = distance*1e-10
                real_energy += coulomb_factor*(q_j*q_l / r_m)*erfc(alpha*distance)

    return real_energy

def build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg):
    alpha = math.radians(alpha_deg)
    beta = math.radians(beta_deg)
    gamma = math.radians(gamma_deg)

    ax = a
    ay = 0.0
    az = 0.0

    bx = b * math.cos(gamma)
    by = b * math.sin(gamma)
    bz = 0.0

    sin_gamma = math.sin(gamma)
    cx = c * math.cos(beta)
    if abs(sin_gamma) < 1e-14:
        sin_gamma = 1e-14
    cy = c * ((math.cos(alpha) - math.cos(beta)*math.cos(gamma)) / sin_gamma)
    cz = math.sqrt(c**2 - cx**2 - cy**2)

    h = np.array([
        [ax, bx, cx],
        [ay, by, cy],
        [az, bz, cz]
    ], dtype=float)

    h_inv = np.linalg.inv(h)
    return h, h_inv

def compute_fourier_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    kmax = system_data['kmax']

    a = system_data['a']
    b = system_data['b']
    c = system_data['c']
    alpha_deg = system_data['alpha_deg']
    beta_deg = system_data['beta_deg']
    gamma_deg = system_data['gamma_deg']

    h, _ = build_triclinic_matrix(a, b, c, alpha_deg, beta_deg, gamma_deg)
    V_m = abs(np.linalg.det(h))*(1e-10**3)

    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    positions_m = positions*1e-10
    prefactor = coulomb_factor/(2.0*V_m)

    alpha_m = alpha*1e10
    fourier_energy = 0.0

    max_sq = kmax*kmax + 2
    L_avg = (a + b + c)/3.0
    kfactor = 2.0*math.pi/(L_avg*1e-10)

    for kx in range(-kmax, kmax+1):
        for ky in range(-kmax, kmax+1):
            for kz in range(-kmax, kmax+1):
                if (kx == 0 and ky == 0 and kz == 0):
                    continue
                if (kx*kx + ky*ky + kz*kz) >= max_sq:
                    continue

                kx_m = kfactor*kx
                ky_m = kfactor*ky
                kz_m = kfactor*kz
                k_sq = kx_m**2 + ky_m**2 + kz_m**2
                if k_sq < 1e-14:
                    continue

                real_part = 0.0
                imag_part = 0.0
                for j, (xj, yj, zj) in enumerate(positions_m):
                    kr = kx_m*xj + ky_m*yj + kz_m*zj
                    real_part += charges_c[j]*math.cos(kr)
                    imag_part += charges_c[j]*math.sin(kr)

                sk_sq = real_part**2 + imag_part**2
                exp_factor = math.exp(-k_sq/(4.0*alpha_m**2))

                term = prefactor*(4.0*math.pi/k_sq)*exp_factor*sk_sq
                fourier_energy += term

    return fourier_energy


def compute_self_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']
    atom_types = configuration['Atom Type'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])
    charges_c = charges*e_charge

    alpha_m = alpha*1e10
    sum_q2 = np.sum(charges_c**2)

    # standard Ewald self
    self_energy = -coulomb_factor*(alpha_m/math.sqrt(math.pi))*sum_q2
    return self_energy


def compute_intra_energies(system_data, configuration, force_field):
    e_charge = 1.602176634e-19
    coulomb_factor = 8.9875517923e9 / 1.3806488e-23

    alpha = system_data['alpha']

    positions = configuration[['X', 'Y', 'Z']].values
    atom_types = configuration['Atom Type'].values
    mol_ids = configuration['Molecule'].values
    charges = np.array([force_field.loc[t, 'charge'] for t in atom_types])

    unique_mols = np.unique(mol_ids)
    intra_energy = 0.0

    for m_id in unique_mols:
        idxs = np.where(mol_ids == m_id)[0]
        for i in range(len(idxs) - 1):
            for j in range(i + 1, len(idxs)):
                idx_i = idxs[i]
                idx_j = idxs[j]
                dx = positions[idx_j, 0] - positions[idx_i, 0]
                dy = positions[idx_j, 1] - positions[idx_i, 1]
                dz = positions[idx_j, 2] - positions[idx_i, 2]
                r = math.sqrt(dx**2 + dy**2 + dz**2)
                if r > 1e-14:
                    q_i = charges[idx_i]*e_charge
                    q_j = charges[idx_j]*e_charge
                    r_m = r*1e-10
                    erf_val = erf(alpha*r)
                    # negative sign for intramolecular
                    val = coulomb_factor*(q_i*q_j / r_m)*erf_val
                    intra_energy -= val

    return intra_energy


# DataFrame Descriptions:

# 1. NIST_TRICLINIC_SPC_E_Water DataFrame:
#    - Contains thermodynamic properties of SPC/E water configurations in both triclinic and monoclinic cells.
#    - Columns:
#        - 'Configuration' (int): Configuration ID (1-4).
#        - 'M (number of SPC/E molecules)' (int): Number of SPC/E molecules in the system.
#        - 'Cell Type' (str): Type of the cell (e.g., Triclinic, Monoclinic).
#        - 'Cell Side Lengths [a, b, c] (Å)' (list of strings): Cell side lengths in Ångströms.
#        - 'Cell Angles [α, β, γ] (degrees)' (list of strings): Cell angles in degrees.
#        - 'Number of Wave Vectors' (int): The number of wave vectors for each configuration.
#        - 'Edisp/kB (K)' (float): Dispersion energy in Kelvin.
#        - 'ELRC/kB (K)' (float): Long-range correction energy in Kelvin.
#        - 'Ereal/kB (K)' (float): Real energy in Kelvin.
#        - 'Efourier/kB (K)' (float): Fourier transform energy in Kelvin.
#        - 'Eself/kB (K)' (float): Self-interaction energy in Kelvin.
#        - 'Eintra/kB (K)' (float): Intra-molecular energy in Kelvin.
#        - 'Etotal/kB (K)' (float): Total energy in Kelvin.

# 2. force_field DataFrame:
#    - Contains force field parameters for SPC/E water, specifically for oxygen ('O') and hydrogen ('H').
#    - Columns:
#        - 'type' (str): Atom type ('O' or 'H').
#        - 'sigma' (float): Lennard-Jones parameter (Å).
#        - 'epsilon' (float): Lennard-Jones well depth (K).
#        - 'charge' (float): Partial charge (e).
#        - 'num_particles' (int): Number of particles per molecule.

# 3. system DataFrame:
#    - Contains metadata about each system configuration.
#    - Columns:
#        - 'file_paths' (str): File names containing atomic configurations.
#        - 'configuration #' (int): Extracted configuration number (1-4).
#        - 'number of particles' (float): Number of molecules (from 'NIST_SPC_E_Water').
#        - 'box length' (float): Box dimensions (from 'NIST_SPC_E_Water').
#        - 'cutoff' (int): Fixed cutoff distance for interactions (10 Å).
#        - 'alpha' (float): Ewald summation parameter (5.6 / min(a, b, c)).
#        - 'kmax' (int): Maximum wave vector index (5); also, only include k for which k² < kmax² + 2, i.e., k² < 27.
#        - 'ε0' (float): Permittivity of Vacuum (8.854187817E-12 C²/(J m)).
#        - 'kB' (float): Boltzmann Constant (1.3806488E-23 J/K).

# 4. configuration DataFrame (from 'extracting_positions'):
#    - Created per file, containing atomic positions.
#    - Columns:
#        - 'X' (float): Atom coordinates in Ångströms.
#        - 'Y' (float): Atom coordinates in Ångströms.
#        - 'Z' (float): Atom coordinates in Ångströms.
#        - 'Atom Type' (str): Type of atom ('O' or 'H').
#        - 'Molecule' (int): Molecule index assigned based on position.


system, force_field, NIST_TRICLINIC_SPC_E_Water = creating_dataframes(file_paths, atom_properties,NIST_TRICLINIC_SPC_E_Water)

# Computing energies storing in results
results = pd.DataFrame()

results['Number of Particles'] = system['number of particles'].astype(int)

# Calculate LRC energy for all system configurations
results['lrc_Energies'] = system.apply(
    lambda row: compute_lrc_energy(row, force_field), axis=1
)

# Calculate pairwise energy for all system configurations
results['dispersion_energies'] = system['file_paths'].apply(
    lambda file_path: pair_dispersion_energy(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path), 
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['real_energies'] = system['file_paths'].apply(
    lambda file_path: compute_real_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['fourier_energies'] = system['file_paths'].apply(
    lambda file_path: compute_fourier_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['self_energies'] = system['file_paths'].apply(
    lambda file_path: compute_self_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

# Calculate pairwise energy for all system configurations
results['intra_energies'] = system['file_paths'].apply(
    lambda file_path: compute_intra_energies(
        system[system['file_paths'] == file_path].iloc[0],  # Ensure single row selection
        extracting_positions(file_path),
        force_field
    )
)

def compare_LJ_coulomb_energy(df1, df2, tolerance=1e-4):
    df_merged = df1.merge(df2, left_on='Number of Particles', right_on='M (number of SPC/E molecules)', how='left')

    matched_real = matched_fourier = matched_self = matched_intra = 0
    matched_dispersion = matched_lrc = 0
    not_matched_real = not_matched_fourier = not_matched_self = not_matched_intra = 0
    not_matched_dispersion = not_matched_lrc = 0
    l2_dispersion = l2_lrc = l2_real = 0.0
    l2_fourier = l2_self = l2_intra = 0.0

    real_energy_output = []
    fourier_energy_output = []
    self_energy_output = []
    intra_energy_output = []
    lrc_energy_output = []
    dispersion_energy_output = []

    for idx, row in df_merged.iterrows():
        real_energy = row['real_energies']
        fourier_energy = row['fourier_energies']
        self_energy = row['self_energies']
        intra_energy = row['intra_energies']
        num_molecules = row['Number of Particles']
        lrc_energy = row['lrc_Energies']
        dispersion_energy = row['dispersion_energies']

        if pd.isna(row['Ereal/kB (K)']):
            continue
        nist_real_energy = float(row['Ereal/kB (K)'])
        nist_fourier_energy = float(row['Efourier/kB (K)'])
        nist_self_energy = float(row['Eself/kB (K)'])
        nist_intra_energy = float(row['Eintra/kB (K)'])
        nist_lrc_energy = float(row['ELRC/kB (K)'])
        nist_dispersion_energy = float(row['Edisp/kB (K)'])

        match_real = np.isclose(real_energy, nist_real_energy, atol=tolerance)
        match_fourier = np.isclose(fourier_energy, nist_fourier_energy, atol=tolerance)
        match_self = np.isclose(self_energy, nist_self_energy, atol=tolerance)
        match_intra = np.isclose(intra_energy, nist_intra_energy, atol=tolerance)
        match_dispersion = np.isclose(dispersion_energy, nist_dispersion_energy, atol=tolerance)
        match_lrc = np.isclose(lrc_energy, nist_lrc_energy, atol=tolerance)

        matched_real += int(match_real)
        not_matched_real += int(not match_real)
        matched_fourier += int(match_fourier)
        not_matched_fourier += int(not match_fourier)
        matched_self += int(match_self)
        not_matched_self += int(not match_self)
        matched_intra += int(match_intra)
        not_matched_intra += int(not match_intra)
        matched_dispersion += int(match_dispersion)
        not_matched_dispersion += int(not match_dispersion)
        matched_lrc += int(match_lrc)
        not_matched_lrc += int(not match_lrc)

        dispersion_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {dispersion_energy:.4E}, NIST: {nist_dispersion_energy:.4E}, Match: {match_dispersion}"")
        lrc_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {lrc_energy:.4E}, NIST: {nist_lrc_energy:.4E}, Match: {match_lrc}"")
        real_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {real_energy:.4E}, NIST: {nist_real_energy:.4E}, Match: {match_real}"")
        fourier_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {fourier_energy:.4E}, NIST: {nist_fourier_energy:.4E}, Match: {match_fourier}"")
        self_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {self_energy:.4E}, NIST: {nist_self_energy:.4E}, Match: {match_self}"")
        intra_energy_output.append(f""Test {idx+1} ({num_molecules} molecules): Computed: {intra_energy:.4E}, NIST: {nist_intra_energy:.4E}, Match: {match_intra}"")

        l2_dispersion = np.square(dispersion_energy - nist_dispersion_energy)
        l2_lrc = np.square(lrc_energy - nist_lrc_energy)
        l2_real = np.square(real_energy - nist_real_energy)
        l2_fourier = np.square(fourier_energy - nist_fourier_energy)
        l2_self = np.square(self_energy - nist_self_energy)
        l2_intra = np.square(intra_energy - nist_intra_energy)

    print()
    print(""Lennard-Jones Pair Dispersion Energy Comparison:"")
    print(*dispersion_energy_output)
    print(""Lennard-Jones long-range corrections Energy Comparison:"")
    print(*lrc_energy_output)
    print(""Real Energy Comparison:"")
    print(*real_energy_output)
    print(""Fourier Energy Comparison:"")
    print(*fourier_energy_output)
    print(""Self Energy Comparison:"")
    print(*self_energy_output)
    print(""Intra Energy Comparison:"")
    print(*intra_energy_output)
    print()
    print(f""Count of correct pairwise answers: {matched_dispersion}"")
    print(f""Count of incorrect pairwise answers: {not_matched_dispersion}"")
    print(f""Count of correct LRC answers: {matched_lrc}"")
    print(f""Count of incorrect LRC answers: {not_matched_lrc}"")
    print(f""Count of correct Real Energy answers: {matched_real}"")
    print(f""Count of incorrect Real Energy answers: {not_matched_real}"")
    print(f""Count of correct Fourier Energy answers: {matched_fourier}"")
    print(f""Count of incorrect Fourier Energy answers: {not_matched_fourier}"")
    print(f""Count of correct Self Energy answers: {matched_self}"")
    print(f""Count of incorrect Self Energy answers: {not_matched_self}"")
    print(f""Count of correct Intra Energy answers: {matched_intra}"")
    print(f""Count of incorrect Intra Energy answers: {not_matched_intra}"")
    print()
    print(f""L2 Value Comparison of Squared Differences Between Computed and NIST Energy Values with tolerance: {tolerance}"")
    print(f""L2 value for Dispersion: {np.sqrt(np.sum(l2_dispersion))}"")
    print(f""L2 value for LRC: {np.sqrt(np.sum(l2_lrc))}"")
    print(f""L2 value for Real Energy: {np.sqrt(np.sum(l2_real))}"")
    print(f""L2 value for Fourier Energy: {np.sqrt(np.sum(l2_fourier))}"")
    print(f""L2 value for Self Energy: {np.sqrt(np.sum(l2_self))}"")
    print(f""L2 value for Intra Energy: {np.sqrt(np.sum(l2_intra))}"")
    total_correct = matched_real + matched_fourier + matched_self + matched_intra + matched_dispersion + matched_lrc
    total_incorrect = not_matched_real + not_matched_fourier + not_matched_self + not_matched_intra + not_matched_dispersion + not_matched_lrc
    print(f""Total correct answers: {total_correct}"")
    print(f""Total incorrect answers: {total_incorrect}"")


# calling compare_coulomb_energy function
compare_LJ_coulomb_energy(results, NIST_TRICLINIC_SPC_E_Water)"
